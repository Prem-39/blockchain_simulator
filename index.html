<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="A blockchain proof-of-work simulation tool.">
		<meta name="author" content="Simeon">
		<link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon">
		<link rel="icon" href="img/favicon.ico" type="image/x-icon">
		<link rel="stylesheet" href="lib/bootstrap.min.css">
		<link href="lib/jsoneditor.min.css" rel="stylesheet" type="text/css">
		<script type="text/javascript" src="lib/vis-network.min.js"></script>
		<script type="text/javascript" src="lib/canvas2svg.js"></script>
		<script src="lib/jsoneditor.min.js"></script>
		<title>Blockchain Simulator</title>
		<style>
			.container {
				max-width: 960px;
				-webkit-transition: height 2s; /* Safari prior 6.1 */
  				transition: height 2s;
			}
			.fillx { 
				min-width: 100%;
				width: 100%;
			}
			.filly { 
				min-height: 100%;
				height: 100%;
			}
			#minerList {
				overflow-y: auto;
			}
			#networkjsoneditor, #topologyjsoneditor {
				height: 500px;
			}
			#jsoneditor, #topologyjsoneditor, #networkjsoneditor {
				background-color: #FFF;
				width: 100%;
			}
			#mynetwork, #minerStatsTable {
				background-color: #343A40;
				transition: opacity 0.5s, height 0.5s, max-height 0.5s;
			}
			.jsoneditor-search, .jsoneditor-frame, .jsoneditor-menu, .jsoneditor-frame table tbody tr td input, option:checked {
				background-color: #343A40 !important;
				color: #FFF !important;
			}
			div .jsoneditor, div .jsoneditor-mode-form, #minerList {
				border-color: #343A40;
				border-radius: 0;
			}
			.jsoneditor-menu { border-bottom: 0 !important; }
			.jsoneditor-text { color: #FFF; }
		</style>
		<style id="miner-colors-selector"></style>
	</head>

<body class="bg-dark py-3">
	<div class="container bg-light rounded pb-3">
		<div class="py-2 text-center">
			<h1 class="display-4 d-inline">Blockchain Simulator</h1> <span class="badge badge-primary">v1.0</span> <span class="badge badge-secondary"><a class="text-white" href="index_v0.12.html">v0.12 can be found here</a></span>
		</div>
		<div class="jumbotron p-3 mb-3">
			<div class="row">
				<div class="col-md-4">
					<div class="row px-3">
						<div class="btn-group fillx" style="max-height: 35px; cursor: pointer">
							<!-- Options -->
							<button type="button" class="btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" onclick="$('#addMinerBadge').text('')" style="width: 100%">
								<span class="sr-only">Toggle Dropdown</span>
								<span id="addMinerBadge" class="badge badge-light"></span>
								Options
							</button>
							<div class="dropdown-menu">
								<a class="dropdown-item" data-toggle="modal" data-target="#addMinerModal" onclick="addMinerBtnClicked()">Add/Edit miner</a>
								<a id="removeMinerBtn" class="dropdown-item" onclick="DOM_removeMiner()">Remove miner</a>
								<a class="dropdown-item" onclick="if(confirm('You\'re about to remove all miners.')) DOM_removeAllMiners()">Remove all miners</a>
								<a class="dropdown-item" onclick="DOM_sortMiners()">Sort miners</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" data-toggle="modal" data-target="#generateTopologyModal"><b>Generate a topology</b></a>
								<a class="dropdown-item" onclick="duplicateTopology()">Duplicate current topology</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="DOM_toggleLoggingNetworkData()" id="DOM_item_toggleLoggingNetworkData">Enable logging network<br>data within each miner</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="DOM_globalSetPower()">Globally set power</a>
								<a class="dropdown-item" onclick="DOM_globalSetLatency()">Globally set latency</a>
								<a class="dropdown-item" onclick="DOM_globalSetDownloadMBPS()">Globally set download MBPS</a>
								<a class="dropdown-item" onclick="DOM_globalSetUploadMBPS()">Globally set upload MBPS</a>
								<a class="dropdown-item" onclick="bidirectionallyConnectPeers()">Connect bidirectionally</a>
								<a class="dropdown-item" onclick="fullyConnectPeers()">Connect all peers</a>
								<a class="dropdown-item" onclick="fullyDisconnectPeers()">Disconnect all peers</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="saveLocalStorage()">Save to LocalStorage</a>
								<a class="dropdown-item" onclick="loadLocalStorage()">Load from LocalStorage</a>
								<a class="dropdown-item" onclick="deleteLocalStorage()">Delete from LocalStorage</a>
								<a class="dropdown-item" onclick="clearAllLocalStorage()">Clear All LocalStorage</a>
							</div>
						</div>
					</div>
					<div class="row px-3" style="height: calc(100% - 70px)">
						<select id="minerList" onclick="DOM_selectedMiner()" onchange="DOM_selectedMiner()" size="6" class="form-control fillx filly">
						</select>
					</div>
					<div class="row px-3">
						<div class="btn-group fillx" style="max-height: 35px; cursor: pointer">
							<button id="toggleMiningBtn" onclick="DOM_toggleAllMining()" type="button" class="btn btn-dark rounded-0" style="width: 100%">Start All Miners</button>
							
							<!-- Miner Options -->
							<button type="button" class="btn btn-dark rounded-0 dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
								<span class="sr-only">Toggle Dropdown</span>
							</button>
							<div class="dropdown-menu">
								<a id="toggleMinerMiningBtn" class="dropdown-item" onclick="DOM_toggleMining()">Toggle mining for miner</a>
								<a id="clearMinerBlockchainBtn" class="dropdown-item" onclick="DOM_clearMinerBlockchain()">Clear blockchain for miner</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="if(confirm('You\'re about to clear everyone\'s blockchain data.')) DOM_clearBlockchain()">Clear all blockchains</a>
								<a class="dropdown-item" onclick="DOM_setNetworkDifficulty()">Set network difficulty</a>
								<a class="dropdown-item" onclick="toggleSha256()" id="useSHA256Btn">Use secure SHA-256 (slower)</a>
								<a class="dropdown-item" onclick="DOM_setBlockSizes()">Set block sizes</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" data-toggle="modal" data-target="#viewNetworkModal" onclick="regenerateNetworkJSON()">View full network</a>
							</div>
						</div>
					</div>
				</div>
				<div class="col-md-8">
					<div class="row px-3">
						<div id="jsoneditor"></div>
						<span id="editMinerBadge" class="ml-auto badge badge-secondary"></span>
					</div>
				</div>
			</div>
		</div>
		<div class="row">
			<div class="col-md-12 mb-3">
				<div class="btn-group fillx" style="max-height: 35px; cursor: pointer">

					<!-- Menu -->
					<button type="button" class="btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" onclick="$('#addMinerBadge').text('')" style="width: 100%">
						<span class="sr-only">Toggle Dropdown</span>
						<span id="addMinerBadge" class="badge badge-light"></span>
					</button>
					<div class="dropdown-menu">
						<a class="dropdown-item" id="vis_refresh_btn" onclick="vis_setupNetworkSimulation()">Refresh topology visualizer</a>
						<a class="dropdown-item" id="vis_line_length_btn" onclick="vis_setLineLengths()">Set line lengths</a>
						<div class="dropdown-divider" id="vis_btn_delimeter" ></div>
						<a class="dropdown-item" onclick="DOM_toggleMinerStatsTable()">Toggle miner stats table</a>
						<a class="dropdown-item" onclick="vis_toggleTopologyVisualizer()">Toggle topology visualizer</a>
						<a class="dropdown-item" onclick="DOM_toggleSamplerForm()">Toggle sampler</a>
					</div>
				</div>
			</div>
			<hr>
		</div>
		<div class="row">
			<div class="col-md-12">
				<div id="mynetwork"></div>
			</div>
		</div>
		<div id="minerStatsDiv" class="row">
			<div class="col-md-12">
				<small>
					<table id="minerStatsTable" class="table table-dark table-hover table-responsive mb-0">
					</table>
				</small>
			</div>
		</div>
		<div id="samplerDiv" class="row">
			<div class="col-md-12">
				<div class="card text-white bg-dark rounded-0 px-2">
					<div class="card-header">
						<div class="form-group row">
							<div class="input-group">
							<label for="timePerSample" class="col-sm-3 col-form-label">Time per sample (s)</label>
							<div class="col-sm-9 p-0">
								<input  id="timePerSample" type="number" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" min="0" value="60" required>
							</div>
							</div>
						</div>
						<div class="form-group row">
							<label for="codeBeforeSampling" class="col-sm-3 col-form-label">Run before sampling</label>
							<div class="col-sm-9 p-0">
								<textarea id="codeBeforeSampling" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" rows="1"></textarea>
							</div>
						</div>
						<div class="form-group row">
							<label for="codeBetweenSamples" class="col-sm-3 col-form-label">Run between samples</label>
							<div class="col-sm-9 p-0">
								<textarea id="codeBetweenSamples" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" rows="2"></textarea>
							</div>
						</div>
						<div class="form-group row">
							<label for="codeAfterSampling" class="col-sm-3 col-form-label">Run after sampling</label>
							<div class="col-sm-9 p-0">
								<textarea id="codeAfterSampling" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" rows="1"></textarea>
							</div>
						</div>
						<div class="form-group row">
							<label class="col-sm-3 col-form-label"></label>
							<div class="col-sm-9 p-0">
								<label class="btn btn-secondary">
									<input id="logSamplesCheckbox" type="checkbox" onchange="saveSamplerSettings()"> Log samples
								</label>
								<label class="btn btn-secondary">
									<input id="resetBlockchainAfterEachSampleCheckbox" type="checkbox" onchange="saveSamplerSettings()" checked> Reset blockchain after each sample
								</label>
								<label class="btn btn-secondary">
									<input id="updateTableAfterEachSampleCheckbox" type="checkbox" onchange="saveSamplerSettings()" checked> Update table
								</label>
							</div>
						</div>
						<div class="form-group row mb-0">
							<button id="toggleSamplingBtn" class="btn btn-primary fillx border border-dark" onclick="toggleSampling()">Begin Sampling</button>
						</div>
					</div>

					<div class="col-md-12 p-2">
						<small>
							<table id="sampleTable" class="table table-dark table-responsive mb-2">
							</table>
						</small>
					</div>
				</div>
			</div>
		</div>

		<!-- Modals -->
		<div class="modal fade" id="addMinerModal" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 class="modal-title">Add or Edit a Miner</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<form>
						<div class="modal-body">
							<div class="form-group row">
								<label for="addMinerName" class="col-sm-4 col-form-label">Name</label>
								<div class="col-sm-8">
									<input type="text" class="form-control" id="addMinerName" value="Bob" onclick="this.select()" onblur="this.value = fixCase(this.value)" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerPower" class="col-sm-4 col-form-label">Computing Power</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerPower" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerLatency" class="col-sm-4 col-form-label">Network Latency (milliseconds)</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerLatency" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerDownloadMBPS" class="col-sm-4 col-form-label">Network Download (mb per second)</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerDownloadMBPS" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerUploadMBPS" class="col-sm-4 col-form-label">Network Upload (mb per second)</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerUploadMBPS" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="multiselectAddPeers" class="col-sm-4 col-form-label">Peers (multiselect)</label>
								<div class="col-sm-8">
									<select id="multiselectAddPeers" multiple="multiple" class="form-control" size="6">
									</select>
								</div>
							</div>
						</div>
						<div class="modal-footer">
							<button id="addMinerSubmit" class="btn btn-default" onclick="DOM_addMiner()" data-dismiss="modal">Add/Edit</button>
						</div>
					</form>
				</div>
			</div>
		</div>
		<div class="modal fade" id="generateTopologyModal" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 class="modal-title">Pick a Topology</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<div class="modal-body">
						<img src="img/topologies.png" style="width: 100%" usemap="#topologies">
						<map id="topologyMap" name="topologies" data-dismiss="modal"  data-toggle="modal" data-target="#generateTopologyModal2">
							<area shape="rect" coords="10, 10, 450, 506" alt="Ring" onclick="DOM_selectTopology('Ring')">
							<area shape="rect" coords="471, 10, 1005, 506" alt="Mesh" onclick="DOM_selectTopology('Mesh')">
							<area shape="rect" coords="1026, 10, 1403, 506" alt="Star" onclick="DOM_selectTopology('Star')">
							<area shape="rect" coords="1424, 10, 1910, 506" alt="Fully Connected" onclick="DOM_selectTopology('Fully Connected')">
							<area shape="rect" coords="10, 527, 740, 931" alt="Line" onclick="DOM_selectTopology('Line')">
							<area shape="rect" coords="761, 527, 1367, 931" alt="Tree" onclick="DOM_selectTopology('Tree')">
							<area shape="rect" coords="1388, 527, 1910, 931" alt="Bus" onclick="DOM_selectTopology('Bus')">
						</map>
					</div>
				</div>
			</div>
		</div>
		<div class="modal fade" id="generateTopologyModal2" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 id="topologyTitle" class="modal-title">Topology</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<form>
						<div class="modal-body">
							<div id="topologyjsoneditor"></div>
						</div>
						<div class="modal-footer">
							<button class="btn btn-default" onclick="DOM_generateTopology()" data-dismiss="modal">Generate</button>
						</div>
					</form>
				</div>
			</div>
		</div>
		<div class="modal fade" id="viewNetworkModal" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 id="topologyTitle" class="modal-title">View Network</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<div class="modal-body">
						<div id="networkjsoneditor"></div>
						<span id="editNetworkBadge" class="ml-auto badge badge-secondary"></span>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- jQuery first, imageMapResizer, then Popper.js, then Bootstrap JS -->
	<script src="lib/jquery-3.2.1.slim.min.js"></script>
	<script src="lib/imageMapResizer.min.js"></script>
	<script src="lib/popper.min.js"></script>
	<script src="lib/bootstrap.min.js"></script>
</body>
<script type="text/javascript">

	let network = null;

	let updateToolOptions = {
		timeout: null,
		minerStatsTable_active: true,
		vis_network: null,
		vis_simulation_active: true,
		vis_timeout: null,
		vis_nodeIDs: [],
		vis_lineLength: undefined,
		sampler_DOM_active: true,
		sampler_running: false,
		samplerData: [],
		samplerLog: [],
		sampleStartTime: 0,
		sampleEndTime: 0
	}


	// Use the 256-bit secure hashing algorithm (SHA256) by calling sha256("data string")
	const sha256 = function a(b) {function c(a,b) {return a>>>b|a<<32-b}for(var d,e,f=Math.pow,g=f(2,32),h="length",i="",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o= {},p=2;64>n;p++)if(!o[p]) {for(d=0;313>d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+="\x80";b[h]%64-56;)b+="\x00";for(d=0;d<b[h];d++) {if(e=b.charCodeAt(d),e>>8)return;j[d>>2]|=e<<(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e<j[h];) {var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64>d;d++) {var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&l[5]^~v&l[6])+m[d]+(q[d]=16>d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s>>>3)+q[d-7]+(c(t,17)^c(t,19)^t>>>10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&l[1]^u&l[2]^l[1]&l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8>d;d++)l[d]=l[d]+r[d]|0}for(d=0;8>d;d++)for(e=3;e+1;e--) {var y=l[d]>>8*e&255;i+=(16>y?0:"")+y.toString(16)}return i};

	// Network class
	class Network {
		constructor() {
			this.peers = {};
			this.difficulty = 0.1;

			this.blockSize = 1000000;

			this.genesis = new Header();
			this.genesis.height = 0;
			this.genesis.timestamp = Date.now();

			this.useSHA256 = false; // Specify whether or not to actually use genuine hashing (real security, but slow), or to use random numbers and a difficulty threshhold to determine a block (no security, but fast)

			this.ID_Registry = {};
			this.miningThreads = {};
			this.minimumBlockchainPurgeLength = 100;
			this.maximumBlockchainPurgeLength = 200; // When a miner's blockchain reaches this many blocks, it will remove the oldest ones until it's the minimumBlockchainPurgeLength

			// When a block is received, keep track of number of networking data, such as the number of hops
			this.logging = {
				logNetworkData: false,
				msPerSample: 20000,
				codeBeforeSampling: "console.log(\"Sampling started at \", Date.now());",
				codeBetweenSamples: "// BOB.power += 10;\nif(numSamples >= 100000) toggleSampling(false);",
				codeAfterSampling: "console.log(\"Sampling ended at \", Date.now());",
				logSamples: false,
				resetBlockchainAfterEachSample: true,
				updateTableAfterEachSample: true
			}
		}

		setDifficulty(_difficulty) {
			_difficulty = _difficulty.toString();

			if(_difficulty.startsWith("0x")) {
				_difficulty = _difficulty.substring(2); // Remove the 0x
				let maxDifficulty = parseInt("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF".substring(0, 15), 16);
				let d = parseInt(_difficulty.substring(0, 15), 16) / maxDifficulty;
				if(!isNaN(d)) {
					this.difficulty = d;
				} else {
					alert(`Invalid difficulty value: "${_difficulty}".`);
				}
			} else {
				let d = parseFloat(_difficulty);
				if(!isNaN(d)) {
					this.difficulty = d;
				} else {
					alert(`Invalid difficulty value: "${_difficulty}".`);
				}
			} 
		}

		startAllMiners() {
			for(let id in network.ID_Registry) {
				network.peers[id].startMining();
			}
		}

		stopAllMiners() {
			for(let id in network.ID_Registry) {
				network.peers[id].stopMining();
			}
			clearAllTimeouts();
		}

		clearBlockchain() {
			for(let id in this.ID_Registry) {
				this.peers[id].clearBlockchain();
			}
			clearAllTimeouts();
		}

		findPeerByName(name) {
			for(let id in this.ID_Registry) {
				if(this.peers[id].name == name) return this.peers[id];
			}
			return null;
		}

		// Given a network object, return it in its serialized JSON form
		static serialize(network) {
			network.stopAllMiners();
			let json = JSON.stringify(network);
			return json
		}

		// Given a serialized network, return the network object (consisting of Network, Miner, Header classes)
		static deserialize(json) {
			clearAllTimeouts();
			let newNetworkObj = JSON.parse(json);
			let network = new Network();
			network = Object.assign(network, newNetworkObj);

			for(let peer in network.peers) { // Make all miners Miner objects

				let miner = new Miner(network.peers[peer].name, network.peers[peer].power, network.peers[peer].latency, network.peers[peer].downloadMBPS, network.peers[peer].uploadMBPS);
				miner = Object.assign(miner, network.peers[peer]);
				network.peers[peer] = miner;

				// Make the currentHeader an actual Header object
				let currentHeader = new Header();
				currentHeader = Object.assign(currentHeader, network.peers[peer].currentHeader);
				network.peers[peer].currentHeader = currentHeader;

				// Make the blocks in the blockchain an actual Header object
				for(let block in network.peers[peer].blockchain) {
					let header = new Header();
					header = Object.assign(header, network.peers[peer].blockchain[block]);
					network.peers[peer].blockchain[block] = header;
				}

				// Recreate the networkBuffer
				let networkBuffer = new NetworkBuffer(miner.ID);
				network.peers[peer].networkBuffer = networkBuffer;
			}
			// Note: miner.blockchain headers are not actually Header objects anymore, this can be fixed by
			return network;
		}
	}

	// Block header class
	class Header {
		constructor() {
			this.solver = null;
			this.height = null;
			this.timestamp = null; // Time block was solved in seconds

			if(network != null) this.numBytes = network.blockSize;
			else this.numBytes = 1000000;

			this.nonce = null;
			this.hash = null;
			this.prevHash = null;
			this.balances = [];
			if(network && network.logging.logNetworkData) {
				this.numHops = 0;
			}
		}

		clone() {
			let newHeader = new Header();
			newHeader.solver = this.solver;
			newHeader.height = this.height;
			newHeader.timestamp = this.timestamp;
			newHeader.hash = this.hash; // Hash doesn't need to be sent, since it can be computed on the receiver's end
			newHeader.prevHash = this.prevHash;
			newHeader.balances = Object.assign({}, this.balances);
			if(network.logging.logNetworkData) {
				newHeader.numHops = this.numHops;
			}
			return newHeader;
		}

		guessNonce() {
			this.nonce = Math.random();
			if(network.useSHA256) {
				// Secure but slower
				const data = this.timestamp.toString() + this.nonce.toString() + this.solver?.toString() + this.height.toString() + this.prevHash?.toString() + this.balances.toString();
				this.hash = sha256(sha256(data));
			} else {
				// Insecure but fast
				this.hash = this.nonce;
			}
		}

		isBlock() {
			if(network.useSHA256) {
				// Secure but slower
				const targetDifficulty = 1152921504606847000; // 0XFFFFFFFFFFFFFFF
				const currentDifficulty = parseInt(this.hash.substring(0, 15), 16);
				return (currentDifficulty / targetDifficulty) <= network.difficulty;
			} else {
				// Insecure but fast
				return this.hash <= network.difficulty;
			}
		}
	}

	class NetworkBuffer {
		constructor(parentID) {
			this.parentID = parentID;
			this.clear();
		}

		clear() {
			let now = Date.now() / 1000;

			// Timestamp assigned to last send/receive packet
			this.downloadBufferTimestamp = now;
			this.uploadBufferTimestamp = now;
			// Time since last time the send/receive function was called
			this.timestampSinceLastSend = now;
			this.timestampSinceLastReceive = now;
		}

		send(to_ID, data) {
			if(network.peers[this.parentID].uploadMBPS == 0) return;
			let now = Date.now() / 1000;
			// If sending data that is 5 megabytes, we upload at 20mbps --> 0.25 seconds
			// If sending data that is 40 megabytes, we upload at 20mbps --> 2 seconds
			let timeToProcessData = (data.numBytes / 1000000) / network.peers[this.parentID].uploadMBPS;

			// Computing the time of next delivery by subtracting time passed, then adding time to process. Future packets will stack up, creating a buffer
			let timePassed = now - this.timestampSinceLastSend;
			this.uploadBufferTimestamp -= timePassed;
			if(this.uploadBufferTimestamp < now) this.uploadBufferTimestamp = now; // If the buffer is empty
			this.uploadBufferTimestamp += timeToProcessData;

			let secondsDelay = this.uploadBufferTimestamp - now;
			secondsDelay += network.peers[this.parentID].latency / 1000; // Time to travel through the network (latency is in milliseconds)
			
			//console.log("Block " + data.height + ": Waiting " + secondsDelay + " seconds before sending to " + to_ID);

			setTimeout(network.peers[to_ID].networkBuffer.receive.bind(network.peers[to_ID].networkBuffer), secondsDelay * 1000, this.parentID, to_ID, data);

			this.timestampSinceLastSend = now;
		}


		receive(from_ID, to_ID, data) {
			if(network.peers[this.parentID].downloadMBPS == 0) return;
			let now = Date.now() / 1000;
			// If sending data that is 5 megabytes, we upload at 20mbps --> 0.25 seconds
			// If sending data that is 40 megabytes, we upload at 20mbps --> 2 seconds
			let timeToProcessData = (data.numBytes / 1000000) / network.peers[this.parentID].downloadMBPS;

			// Computing the time of next delivery by subtracting time passed, then adding time to process. Future packets will stack up, creating a buffer
			let timePassed = now - this.timestampSinceLastReceive;
			this.downloadBufferTimestamp -= timePassed;
			if(this.downloadBufferTimestamp < now) this.downloadBufferTimestamp = now; // If the buffer is empty
			this.downloadBufferTimestamp += timeToProcessData;

			let secondsDelay = this.downloadBufferTimestamp - now;
			secondsDelay += network.peers[this.parentID].latency / 1000; // Time to travel through the network (latency is in milliseconds)

			console.log("Block " + data.height + ": Waiting " + secondsDelay + " seconds before receiving from " + from_ID);

			// Send it to the receiver's block processing code
			setTimeout(network.peers[this.parentID].receive.bind(network.peers[this.parentID]), secondsDelay * 1000, from_ID, data);

			this.timestampSinceLastReceive = now;
		}
	}

	// Miner class
	class Miner {
		constructor(name, power, latency, downloadMBPS, uploadMBPS) {
			this.name = name;
			// Register a unique ID
			if(network.ID_Registry[this.name] === undefined) {
				this.ID = this.name.toUpperCase().replace(/\s/g, "_"); // Math.random().toString();
			} else { // Guarentee that no peers have the same ID
				let count = 1;
				do {
					this.ID = this.name.toUpperCase().replace(/\s/g, "_") + count;
					count++;
				} while(network.ID_Registry[this.ID] !== undefined);
			}
			network.ID_Registry[this.ID] = null;
			network.peers[this.ID] = this;
			this.power = power;
			this.latency = latency; // Additional latency from the network (milliseconds)
			this.downloadMBPS = downloadMBPS; // Used by the download buffer to receive data
			this.uploadMBPS = uploadMBPS; // Used by the upload buffer to send data
			this.incomingPeers = [];
			this.outgoingPeers = [];

			this.mineInvalidMaliciousBlocks = false; // When enabled, this miner will mine like other miners, however when a "block" is found, it is actually an invalid block, so adjacent nodes will decline it, but it will have already used up part of the neighboring node's bandwidths

			this.blockchainOffset = 0; // Due to removing old blocks
			this.blockchain = [network.genesis];
			this.totalBlocksFound = 0;
			this.staleBlocksFound = 0;
			this.largestForkLength = 0;
			this.currentHeader = this.newHeader(network.genesis);
			this.color = "default";
			this.networkBuffer = new NetworkBuffer(this.ID);
			updateTools();
		}

		destructor() {
			this.stopMining();
			let incomingPeersBackup = this.incomingPeers.slice();
			let outgoingPeersBackup = this.outgoingPeers.slice();

			for(let id of outgoingPeersBackup) {
				this.removeConnection(id);
			}
			for(let id of incomingPeersBackup) {
				if(network.peers[id] !== undefined) {
					network.peers[id].removeConnection(this.ID);
				}
			}
			delete network.ID_Registry[this.ID];
			updateTools();
		}

		getBlock(height) {
			return this.blockchain[height - this.blockchainOffset];
		}

		setBlock(height, block) {
			if(network.logging.logNetworkData) { // Keep track of networking data
				// If there is a fork, it will always stay up to date by replacing the old stale block data
				this.blockchain_numHops[height] = block.numHops;
				this.blockchain_blockDelay[height] = Date.now() / 1000 - block.timestamp;
			}
			this.blockchain[height - this.blockchainOffset] = block;
		}

		// Clear all blockchain data
		clearBlockchain() {
			this.blockchainOffset = 0;
			this.blockchain = [network.genesis];
			this.currentHeader = this.newHeader(network.genesis);
			this.totalBlocksFound = 0;
			this.staleBlocksFound = 0;
			this.largestForkLength = 0;
		}

		// Check if it is time to remove old blocks, if it is, remove them
		purgeBlockCheck() {
			if(this.blockchain.length >= network.maximumBlockchainPurgeLength) {
				this.blockchainOffset += this.blockchain.length - network.minimumBlockchainPurgeLength;
				this.blockchain = this.blockchain.slice(this.blockchain.length - network.minimumBlockchainPurgeLength);
			}
		}

		startMining() {
			if(network.miningThreads[this.ID] !== undefined) return;
			if(this.power == 0) return;
			network.miningThreads[this.ID] = setInterval(this.mine.bind(this), 1000 / this.power);
			$("#minerList option[value='" + this.ID + "']").html("&#10148; " + this.name);
		}

		stopMining() {
			clearInterval(network.miningThreads[this.ID]);
			this.networkBuffer.clear();

			delete network.miningThreads[this.ID];
			$("#minerList option[value='" + this.ID + "']").html(this.name);
		}

		mine() {
			this.currentHeader.timestamp = Date.now() / 1000;
			this.currentHeader.guessNonce();
			if(this.currentHeader.isBlock()) {
				//console.log(this.name + " found a block!");

				if(this.mineInvalidMaliciousBlocks) {
					// If it's a malicious node, void the block by guessing another nonce until it is not a block
					do {
						this.currentHeader.guessNonce();
					} while(!this.currentHeader.isBlock());
					this.totalBlocksFound++;
					this.submit(this.currentHeader);
					return;
				}

				this.totalBlocksFound++;
				this.submit(this.currentHeader);
				// Set it as the new currentHeader, to mine off of
				this.setBlock(this.currentHeader.height, this.currentHeader);
				this.currentHeader = this.newHeader(this.currentHeader);
				this.purgeBlockCheck();
			}
		}

		addConnection(ID) {
			if(this.ID == ID) return;
			this.outgoingPeers.push(ID);
			network.peers[ID].incomingPeers.push(this.ID);
			updateTools();
		}

		removeConnection(ID) {
			//delete this.outgoingPeers[ID];

			// Go through our connections, remove the ID
			for(let i in this.outgoingPeers) {
				if(this.outgoingPeers[i] == ID) {
					this.outgoingPeers.splice(i, 1);
				}
			}

			// Remove us from that peer's incoming peer list
			if(network.peers[ID] !== undefined) {
				//delete network.peers[ID].incomingPeers[this.ID];
				for(let i in network.peers[ID].incomingPeers) {
					if(network.peers[ID].incomingPeers[i] == this.ID) {
						network.peers[ID].incomingPeers.splice(i, 1);
					}
				}
			}
			updateTools();
		}

		newHeader(prevHeader) { //* Consider sending prevHash instead
			const header = new Header();
			header.solver = this.ID;
			header.height = prevHeader.height + 1;
			header.hash = Number.MAX_SAFE_INTEGER;
			header.prevHash = prevHeader.hash;
			header.balances = Object.assign({}, prevHeader.balances);
			if(header.balances[this.ID] === undefined) {
				header.balances[this.ID] = 1;
			} else {
				header.balances[this.ID]++;
			}
			return header;
		}

		// Broadcast a header to all peers
		submit(header) {
			if(network.logging.logNetworkData) {
				// Keep track of number of hops
				if(header.numHops === undefined) header.numHops = 1;
				else header.numHops++;
			}
			for(let id of this.outgoingPeers) {
				// Old version of block broadcasting, does not consider download and upload bandwidth
				//setTimeout(function(header){
				//	network.peers[id].receive(header);
				//}, this.latency, header.clone());

				this.networkBuffer.send(id, header.clone());
			}
		}

		// Called when a header is received
		receive(from_ID, newHeader) {
			//console.log("Block " + newHeader.height + ": Received by " + this.ID);
			if(!newHeader.isBlock()) {
				console.log(this.name + " received a fake block from " + from_ID + ".", newHeader)
				return;
			}
			if(newHeader.height >= this.blockchain.length + this.blockchainOffset) {
				// If at any point in receiving a block, there is an undefined header, this allows us to undo to the previous working header
				let backupHeaders = [];
				backupHeaders.push(this.getBlock(newHeader.height));
				this.setBlock(newHeader.height, newHeader);
				this.currentHeader = this.newHeader(newHeader);
				let solver = network.peers[newHeader.solver];
				//let newHeader = newHeader; // Go back through the blockchain until we reach the block that both miners share
				let forkLength = 1;
				while(this.getBlock(newHeader.height - 1) === undefined || newHeader.prevHash != this.getBlock(newHeader.height - 1).hash) {
					 // Stale block detector
					if(this.getBlock(newHeader.height - 1) !== undefined && this.ID == this.getBlock(newHeader.height - 1).solver) {
						this.staleBlocksFound++;
						//console.log(this.getBlock(newHeader.height - 1).solver + "'s block became stale");
					}
					let i = newHeader.height;
					newHeader = solver.queryBlockAtHeight(newHeader.height - 1);
					if(newHeader === undefined) {
						while(backupHeaders.length > 0) {
							this.setBlock(i, backupHeaders.pop());
							i++;
						}
						//console.log("Recovered from incomplete transfer");
						return;
					}
					backupHeaders.push(this.getBlock(newHeader.height));
					this.setBlock(newHeader.height, newHeader);
					forkLength++;
				} // Fully synced blockchain!
				if(forkLength > this.largestForkLength) {
					this.largestForkLength = forkLength;
				}
				this.purgeBlockCheck();
				this.submit(this.getBlock(this.blockchain.length + this.blockchainOffset - 1));
			}
		}

		queryBlockAtHeight(height) {
			if(this.getBlock(height) === undefined) return;
			return this.getBlock(height).clone();
		}
	}

	network = new Network();
	// Quickly mine the genesis block
	do {
		network.genesis.guessNonce();
	} while(!network.genesis.isBlock());

	const jsoneditorContainer = document.getElementById("jsoneditor");
	const jsoneditor = new JSONEditor(jsoneditorContainer, {
		mode: "tree",
		modes: ["code", "form", "tree"],
		onChangeText: function (jsonString) {
			DOM_editMiner();
		}
	});
	const topologyjsoneditorContainer = document.getElementById("topologyjsoneditor");
	const topologyjsoneditor = new JSONEditor(topologyjsoneditorContainer, {
		mode: "form",
		modes: ["code", "form", "text", "tree", "view"]
	});
	const networkjsoneditorContainer = document.getElementById("networkjsoneditor");
	const networkjsoneditor = new JSONEditor(networkjsoneditorContainer, {
		mode: "view",
		modes: ["code", "form", "text", "tree", "view"],
		onChangeText: function (jsonString) {
			DOM_editNetwork();
		}
	});

	// Clear all currently running timeouts
	function clearAllTimeouts() {
		var id = window.setTimeout(function() {}, 0);
		while (id--) {
			window.clearTimeout(id);
		}
	}

	// bob --> Bob
	function fixCase(str) {
		return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
	}

	// Generate a random integer between a and b
	function rnd(a, b) {
		if(a == b) return a;
		else if(b > a) [a, b] = [b, a];
		return Math.floor(a + Math.random() * (b - a + 1));
	}

	// Randomize array in-place using Durstenfeld shuffle algorithm
	function shuffleArray(array) {
		for (var i = array.length - 1; i > 0; i--) {
			var j = Math.floor(Math.random() * (i + 1));
			var temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	// Create a new miner
	function newMiner(name0, power, latency, downloadMBPS, uploadMBPS, createNewIfExists = true) {
		let name = name0;
		if(createNewIfExists) {
			// Create a new name/miner by appending a counter to the end, so that the name is unique
			let count = 2;
			while(network.findPeerByName(name) != null) {
				name = name0 + count.toString();
				count++;
			}
		}

		for(let id in network.ID_Registry) {
			if(network.peers[id].name == name) return;
		}
		const miner = new Miner(name, power, latency, downloadMBPS, uploadMBPS);
		$("#minerList").append("<option value=\"" + miner.ID + "\">" + miner.name + "</option>");
		selectMiner(miner.ID); // Select it
		return miner;
	}

	// Connect every peer to every other peer
	function fullyConnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 in network.ID_Registry) {
				network.peers[id1].addConnection(id2);
			}
		}
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Make all peer connections bidirectional
	function bidirectionallyConnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 of network.peers[id1].outgoingPeers) {
				network.peers[id2].addConnection(id1);
			}
		}
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Disonnect every peer to every other peer
	function fullyDisconnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 in network.ID_Registry) {
				network.peers[id1].removeConnection(id2);
			}
		}
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Remove everyone's copy of the blockchain
	function DOM_clearBlockchain() {
		network.stopAllMiners();
		network.clearBlockchain();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Clear the selected miner's blockchain
	function DOM_clearMinerBlockchain() {
		const e = $("#minerList option:selected");
		const miner = network.peers[e.val()];
		if(miner === undefined) {
			$("#addMinerBadge").attr("class", "badge badge-warning");
			$("#addMinerBadge").text("NO MINER SELECTED");
		} else {
			miner.clearBlockchain();
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("SUCCESS");
		}
	}

	$(document).ready(function() {

		// First try loading the filename "", if it doesn't exist, then generate a random topology
		if(loadLocalStorageQuiet("") == false) {
			generateTopology({
				"Type": "Mesh",
				"Bidirectional": true,
				"Prevent duplicate connections": true,
				"Number of peers": 10,
				"Minimum number of connections": 1,
				"Maximum number of connections": 1,
				"Minimum power": 20,
				"Maximum power": 20,
				"Minimum download megabytes per second": 10,
				"Maximum download megabytes per second": 10,
				"Minimum upload megabytes per second": 10,
				"Maximum upload megabytes per second": 10,
				"Minimum latency": 10,
				"Maximum latency": 100,
			  "Naming cycle": ["Alice", "Andrew", "Bob", "Chris", "George", "James", "Jack", "Eve", "Frank", "Carl"]
			  //let minerNames = ["Aaron", "Adam", "Alan", "Albert", "Alex", "Alice", "Andrew", "Anthony", "Arthur", "Austin", "Ben", "Bill", "Bob", "Bobby", "Brandon", "Brian", "Bruce", "Carl", "Charles", "Chris", "Dan", "Daniel", "David", "Dennis", "Donald", "Douglas", "Dylan", "Edward", "Eric", "Ethan", "Eugene", "Frank", "Gabriel", "Gary", "George", "Gerald", "Gregory", "Harold", "Harry", "Henry", "Jack", "Jacob", "James", "Jason", "Jeffrey", "Jeremy", "Jerry", "Jesse", "Joe", "John", "Johnny", "Jonathan", "Jordan", "Jose", "Joseph", "Joshua", "Juan", "Justin", "Keith", "Kenneth", "Kevin", "Kyle", "Larry", "Lawrence", "Logan", "Louis", "Mark", "Matthew", "Michael", "Nathan", "Nicholas", "Noah", "Patrick", "Paul", "Peter", "Philip", "Ralph", "Randy", "Raymond", "Richard", "Robert", "Roger", "Ronald", "Roy", "Russell", "Ryan", "Samuel", "Scott", "Sean", "Stephen", "Steven", "Terry", "Thomas", "Timothy", "Tyler", "Vincent", "Walter", "Wayne", "Will", "Zachary"];
			});
			loadSamplerSettings();
			saveSamplerSettings();
		}
		$("#minerList option:first").prop("selected", true);
		$("#minerList option:first").change();
		$("#addMinerBadge").text("");
		updateToolOptions.minerStatsTable_active = !updateToolOptions.minerStatsTable_active;
		DOM_toggleMinerStatsTable();
		updateToolOptions.vis_simulation_active = !updateToolOptions.vis_simulation_active;
		vis_toggleTopologyVisualizer();
	});

	function saveLocalStorage() {
		let filename = prompt("Saving a file as an empty string will load it every time the page is refreshed.\n\nEnter a file name:");
		if(filename == null) return;
		filename = "NETWORK_FILE_" + filename;

		let json = Network.serialize(network);
		localStorage.setItem(filename, json);
	}

	function loadLocalStorage() {
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith("NETWORK_FILE_")) {
				files.push(key.substring(13));
			}
		}
		let filename = prompt("Files:\n[\"" + files.join("\", \"") + "\"]\n\nPlease enter a file name to load:");
		if(filename == null) return;
		filename = "NETWORK_FILE_" + filename;

		let json = localStorage.getItem(filename);
		if(json == null) {
			alert("File could not be found.")
		} else {
			network = Network.deserialize(json);
			updateTools();
			updateMinerList();
			loadSamplerSettings();
			if(Object.keys(network.peers).length > 0) selectMiner(Object.keys(network.peers)[0]);
			DOM_toggleLoggingNetworkData(network.logging.logNetworkData);
		}
	}



	function loadLocalStorageQuiet(filename) {
		filename = "NETWORK_FILE_" + filename;

		let json = localStorage.getItem(filename);
		if(json == null) {
			return false;
		} else {
			network = Network.deserialize(json);
			updateTools();
			updateMinerList();
			loadSamplerSettings();
			DOM_toggleLoggingNetworkData(network.logging.logNetworkData);
		}
		return true;
	}

	function deleteLocalStorage() {
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith("NETWORK_FILE_")) {
				files.push(key.substring(13));
			}
		}
		let filename = prompt("Files:\n[" + files.join(", ") + "]\n\nPlease enter a file name to delete:");
		if(filename == null) return;
		filename = "NETWORK_FILE_" + filename;

		localStorage.removeItem(filename);
	}

	function clearAllLocalStorage() {
		if(confirm("Are you sure you would like to clear all the saved networks from your browser?")) {
			localStorage.clear();
			alert("LocalStorage has been cleared.")
		}
	}

	// Called when a node is created or deleted
	function updateTools() {
		if(updateToolOptions.timeout != null) return;
		updateToolOptions.timeout = setTimeout(_updateTools, 300);
	}

	// Cannot be called more than once every 300ms
	function _updateTools() {
		if(updateToolOptions.minerStatsTable_active) {
			updateMinerStatsTable();
		}
		if(updateToolOptions.vis_simulation_active) {
			vis_setupNetworkSimulation();
		}
		updateToolOptions.timeout = null;
	}

	// Update the list of miners
	function updateMinerList() {
		$("#minerList").empty();
		for(let peer in network.peers) {
			$("#minerList").append("<option value=\"" + peer + "\">" + network.peers[peer].name + "</option>");
		}
	}

	function addMinerBtnClicked() {
		$("#multiselectAddPeers").empty();
		for(let id in network.ID_Registry) {
			$("#multiselectAddPeers").append("<option value=\'" + id + "\'>" + network.peers[id].name + "</option>")
		}
		const selectionID = $("#minerList option:selected").val();
		if(selectionID !== undefined) {
			const miner = network.peers[selectionID];
			$("#addMinerName").val(miner.name);
			$("#addMinerPower").val(miner.power);
			$("#addMinerLatency").val(miner.latency);
			$("#addMinerDownloadMBPS").val(miner.downloadMBPS);
			$("#addMinerUploadMBPS").val(miner.uploadMBPS);
			for(let id of miner.outgoingPeers) {
				$("#multiselectAddPeers option[value=" + id + "]").prop("selected", true);
			}
			
		}
	}

	function DOM_selectedMiner() {
		const miner = network.peers[$("#minerList").val()];
		updateMinerJsonEditor(miner);
		if(miner === undefined) return;

		$("#removeMinerBtn").text("Remove " + miner.name);
		$("#toggleMinerMiningBtn").text("Toggle mining for " + miner.name);
		$("#clearMinerBlockchainBtn").text("Clear blockchain for  " + miner.name);
		
		$("#editMinerBadge").text("");
		if(updateToolOptions.vis_simulation_active) try {
			updateToolOptions.vis_network.selectNodes([updateToolOptions.vis_nodeIDs[miner.ID]]);
		} catch(e) {}
	}

	// Update the data in the json editor, if id is not provided, just use the selected one from the table
	function updateMinerJsonEditor(id) {
		if(id === undefined) id = network.peers[$("#minerList").val()];

		if(id === undefined) jsoneditor.set({});
		else jsoneditor.set(id);
	}

	// Select a miner from the mining list
	function selectMiner(id) {
		$("#minerList option:selected").prop("selected", false);
		if(id === undefined) return;
		$("#minerList option[value='" + id + "']").prop("selected", true);
		$("#minerList option:selected").change();
	}

	$("#addMinerModal").on("shown.bs.modal", function (e) {
		$("#addMinerBadge").text("");
	});

	$("#generateTopologyModal").on("shown.bs.modal", function (e) {
		$("map").imageMapResize();
	});

	function DOM_globalSetPower() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the computing power of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "10, 100");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseInt(input.trim());
			num2 = num1;
		} else {
			num1 = parseInt(input.substring(0, i).trim());
			num2 = parseInt(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].power = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_globalSetLatency() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the network latency (in milliseconds) of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "10, 100");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseInt(input.trim());
			num2 = num1;
		} else {
			num1 = parseInt(input.substring(0, i).trim());
			num2 = parseInt(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].latency = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_globalSetDownloadMBPS() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the network download megabytes per second of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "0.5, 10");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseInt(input.trim());
			num2 = num1;
		} else {
			num1 = parseInt(input.substring(0, i).trim());
			num2 = parseInt(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].downloadMBPS = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_globalSetUploadMBPS() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the network upload megabytes per second of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "0.5, 10");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseInt(input.trim());
			num2 = num1;
		} else {
			num1 = parseInt(input.substring(0, i).trim());
			num2 = parseInt(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].uploadMBPS = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_addMiner() {
		$("#addMinerName").val(fixCase($("#addMinerName").val()));
		const name = fixCase($("#addMinerName").val());
		const power = parseFloat($("#addMinerPower").val());
		const latency = parseFloat($("#addMinerLatency").val());
		const downloadMBPS = parseFloat($("#addMinerDownloadMBPS").val());
		const uploadMBPS = parseFloat($("#addMinerUploadMBPS").val());
		const peers = $("#multiselectAddPeers").val();
		let miner = newMiner(name, power, latency, downloadMBPS, uploadMBPS, false);
		if(miner === undefined) {
			// The same name exists, check if any options have changed, otherwise edit the miner
			miner = network.findPeerByName(name);
			if(miner.power == power && miner.latency == latency && miner.downloadMBPS == downloadMBPS && miner.uploadMBPS == uploadMBPS) {
				let noChanges = true;
				for(let id of peers) {
					if(miner.ID == id) continue;
					if(miner.outgoingPeers[id] === undefined) {
						noChanges = false;
						break;
					}
				}
				for(let id of miner.outgoingPeers) {
					if(miner.ID == id) continue;
					if(!peers.includes(id)) {
						noChanges = false;
						break;
					}
				}
				if(noChanges) {
					$("#addMinerBadge").attr("class", "badge badge-primary");
					$("#addMinerBadge").text("NO CHANGES WERE MADE");
					return;
				}
			}
			miner.power = power;
			miner.latency = latency;
			miner.downloadMBPS = downloadMBPS;
			miner.uploadMBPS = uploadMBPS;
			for(let id of miner.outgoingPeers) {
				miner.removeConnection(id);
			}
			for(let id of peers) {
				if(!miner.outgoingPeers.includes(id)) {
					miner.addConnection(id);
				}
			}
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("EDITED " + miner.name.toUpperCase());
		} else {
			for(let id of peers) {
				if(!miner.outgoingPeers.includes(id)) {
					miner.addConnection(id);
				}
			}
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("ADDED " + miner.name.toUpperCase());
		}
	}

	function DOM_removeMiner() {
		const e = $("#minerList option:selected");
		const miner = network.peers[e.val()];
		const name = miner.name;
		if(miner === undefined) {
			$("#addMinerBadge").attr("class", "badge badge-warning");
			$("#addMinerBadge").text("NO MINER SELECTED");
		} else {
			miner.destructor();
			delete network.peers[e.val()];
			e.remove();
			$("#removeMinerBtn").text("Remove miner");
			$("#toggleMinerMiningBtn").text("Toggle mining for miner");
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("REMOVED " + name.toUpperCase());
		}
	}

	function DOM_removeAllMiners() {
		for(let id in network.ID_Registry) {
			network.peers[id].destructor();
		}
		network.peers = {};
		network.ID_Registry = {};
		$("#minerList").empty();
		$("#removeMinerBtn").text("Remove miner");
		$("#toggleMinerMiningBtn").text("Toggle mining for miner");
	}

	function DOM_sortMiners() {
		const options = $("#minerList option");
		options.sort(function(a, b) {
			if (a.text.toUpperCase() > b.text.toUpperCase()) return 1;
			else if (a.text.toUpperCase() < b.text.toUpperCase()) return -1;
			else return 0;
		});
		$("#minerList").empty().append(options);
	}

	// Duplicates the current network to create two instances of it
	function duplicateTopology() {
		if(!confirm("You are about to duplicate your topology, the number of peers will double.\n\nContinue?")) return;
		let minerNames = ["Aaron", "Adam", "Alan", "Albert", "Alex", "Alice", "Andrew", "Anthony", "Arthur", "Austin", "Ben", "Bill", "Bob", "Bobby", "Brandon", "Brian", "Bruce", "Carl", "Charles", "Chris", "Dan", "Daniel", "David", "Dennis", "Donald", "Douglas", "Dylan", "Edward", "Eric", "Ethan", "Eugene", "Frank", "Gabriel", "Gary", "George", "Gerald", "Gregory", "Harold", "Harry", "Henry", "Jack", "Jacob", "James", "Jason", "Jeffrey", "Jeremy", "Jerry", "Jesse", "Joe", "John", "Johnny", "Jonathan", "Jordan", "Jose", "Joseph", "Joshua", "Juan", "Justin", "Keith", "Kenneth", "Kevin", "Kyle", "Larry", "Lawrence", "Logan", "Louis", "Mark", "Matthew", "Michael", "Nathan", "Nicholas", "Noah", "Patrick", "Paul", "Peter", "Philip", "Ralph", "Randy", "Raymond", "Richard", "Robert", "Roger", "Ronald", "Roy", "Russell", "Ryan", "Samuel", "Scott", "Sean", "Stephen", "Steven", "Terry", "Thomas", "Timothy", "Tyler", "Vincent", "Walter", "Wayne", "Will", "Zachary"];
		shuffleArray(minerNames);
		try {
			if(network.peers[Object.keys(network.ID_Registry)[0]].name.length == 1) {
				minerNames = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
			}
		} catch(e) {}

		let translation = {};

		for(let peerID in network.peers) {
			let peer = network.peers[peerID];
			let newName = minerNames[0];
			for(let name of minerNames) {
				if(network.findPeerByName(name) == null) {
					newName = name;
					break;
				}
			}
			let miner = newMiner(newName, peer.power, peer.latency, peer.downloadMBPS, peer.uploadMBPS, true);
			translation[peer.ID] = miner.ID;
		}
		for(let peerID in translation) {
			let peer = network.peers[peerID];
			let newPeer = network.peers[translation[peerID]];
			for(let outgoingPeer of peer.outgoingPeers) {
				outgoingPeersTranslation = translation[outgoingPeer];

				if(outgoingPeersTranslation === undefined) continue;
				newPeer.addConnection(outgoingPeersTranslation);
			}
		}
	}

	function DOM_toggleLoggingNetworkData(override) {
		if(override !== undefined) network.logging.logNetworkData = !override;
		if(network.logging.logNetworkData) {
			network.logging.logNetworkData = false;
			$("DOM_item_toggleLoggingNetworkData").text("Enable logging network<br>data within each miner");
			if(network) for(peerID in network.peers) { // Clean up
				delete network.peers[peerID]["blockchain_numHops"];
				delete network.peers[peerID]["blockchain_blockDelay"];
			}
		} else {
			$("DOM_item_toggleLoggingNetworkData").text("Disable logging network<br>data within each miner");

			if(network) for(peerID in network.peers) { // Initialization
				network.peers[peerID]["blockchain_numHops"] = [];
				network.peers[peerID]["blockchain_blockDelay"] = []
			}
			network.logging.logNetworkData = true;
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	// Refresh the full network data viewer
	function regenerateNetworkJSON() {
		networkjsoneditor.set(network);
		//alert(JSON.stringify(network))
	}

	function DOM_editMiner() {
		network.stopAllMiners();
		const miner = jsoneditor.get();
		if(miner === undefined) {
			$("#editMinerBadge").attr("class", "ml-auto badge badge-danger");
			$("#editMinerBadge").text("NO DATA");
		} else if(miner.ID === undefined) {
			$("#editMinerBadge").attr("class", "ml-auto badge badge-danger");
			$("#editMinerBadge").text("MINER NOT FOUND");
		} else if(network.peers[miner.ID] === undefined) {
			$("#editMinerBadge").attr("class", "ml-auto badge badge-warning");
			$("#editMinerBadge").text("ID NOT FOUND");
		} else if(typeof miner.power != "number" || typeof miner.latency != "number" || typeof miner.downloadMBPS != "number" || typeof miner.uploadMBPS != "number") {
			// Type checking
			$("#editMinerBadge").attr("class", "ml-auto badge badge-danger");
			$("#editMinerBadge").text("MUST BE A NUMBER");
		} else {
			// Merge the changes into the peer, excluding the current header
			miner.currentHeader = network.peers[miner.ID].currentHeader;
			miner.networkBuffer = network.peers[miner.ID].networkBuffer;
			Object.assign(network.peers[miner.ID], miner);
			$("#minerList  option[value='" + miner.ID + "']").text(miner.name);
			$("#editMinerBadge").attr("class", "ml-auto badge badge-primary");
			$("#editMinerBadge").text("SUCCESSFULLY SAVED");
		}
	}

	// TODO: Enable editing the network directly
	function DOM_editNetwork() {
		/*const newNetwork = networkjsoneditor.get();
		if(newNetwork === undefined) {
			$("#editNetworkBadge").attr("class", "ml-auto badge badge-danger");
			$("#editNetworkBadge").text("ERROR");
		} else {
			// Merge the changes into the peer, excluding the current header
			Object.assign(network, newNetwork);
			$("#editNetworkBadge").attr("class", "ml-auto badge badge-primary");
			$("#editNetworkBadge").text("SUCCESSFULLY SAVED");
		}*/
		$("#editNetworkBadge").attr("class", "ml-auto badge badge-warning");
		$("#editNetworkBadge").text("NOT SAVED");
	}

	function DOM_selectTopology(topology) {
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("");
		$("#topologyTitle").text(topology + " Topology");
		let options = {};
		switch(topology) {
			case "Ring":
				options = {
					"Type": topology,
					"Bidirectional": false,
					"Number of peers": 6,
					"Minimum power": 20,
					"Maximum power": 20,
					"Minimum download megabytes per second": 10,
					"Maximum download megabytes per second": 10,
					"Minimum upload megabytes per second": 10,
					"Maximum upload megabytes per second": 10,
					"Minimum latency": 10,
					"Maximum latency": 100,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Mesh":
				options = {
					"Type": "Mesh",
					"Bidirectional": true,
					"Prevent duplicate connections": true,
					"Number of peers": 10,
					"Minimum number of connections": 1,
					"Maximum number of connections": 1,
					"Minimum power": 20,
					"Maximum power": 20,
					"Minimum download megabytes per second": 10,
					"Maximum download megabytes per second": 10,
					"Minimum upload megabytes per second": 10,
					"Maximum upload megabytes per second": 10,
					"Minimum latency": 10,
					"Maximum latency": 100,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				  	//"Naming cycle": ["Alice", "Andrew", "Bob", "George", "Jack", "Eve", "Frank", "Carl"]
				};
				break;
			case "Star":
				options = {
					"Type": topology,
					"Bidirectional": true,
					"Towards center (if bidirectional=false)": true,
					"Number of peers": 6,
					"Minimum power": 20,
					"Maximum power": 20,
					"Minimum download megabytes per second": 10,
					"Maximum download megabytes per second": 10,
					"Minimum upload megabytes per second": 10,
					"Maximum upload megabytes per second": 10,
					"Minimum latency": 10,
					"Maximum latency": 100,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Fully Connected":
				options = {
					"Type": topology,
					"Number of peers": 4,
					"Minimum power": 20,
					"Maximum power": 20,
					"Minimum download megabytes per second": 10,
					"Maximum download megabytes per second": 10,
					"Minimum upload megabytes per second": 10,
					"Maximum upload megabytes per second": 10,
					"Minimum latency": 10,
					"Maximum latency": 100,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Line":
				options = {
					"Type": topology,
					"Bidirectional": true,
					"Number of peers": 6,
					"Minimum power": 20,
					"Maximum power": 20,
					"Minimum download megabytes per second": 10,
					"Maximum download megabytes per second": 10,
					"Minimum upload megabytes per second": 10,
					"Maximum upload megabytes per second": 10,
					"Minimum latency": 10,
					"Maximum latency": 100,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Tree":
				options = {
					"Type": topology,
					"Bidirectional": true,
					"Structure": [[[],[],[]],[[],[],[]],[[],[],[]]],
					"Minimum power": 20,
					"Maximum power": 20,
					"Minimum download megabytes per second": 10,
					"Maximum download megabytes per second": 10,
					"Minimum upload megabytes per second": 10,
					"Maximum upload megabytes per second": 10,
					"Minimum latency": 10,
					"Maximum latency": 100,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Bus":
				options = {
					"Type": topology,
					"Number of peers": 6,
					"Minimum power": 20,
					"Maximum power": 20,
					"Minimum download megabytes per second": 10,
					"Maximum download megabytes per second": 10,
					"Minimum upload megabytes per second": 10,
					"Maximum upload megabytes per second": 10,
					"Minimum latency": 10,
					"Maximum latency": 100,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			default:
				return;
		}
		topologyjsoneditor.set(options);

	}

	function DOM_generateTopology() {
		try {
			// Do an extra check to disable the network visualizer if it may be too computationally taxing
			let json = topologyjsoneditor.get();
			if(json["Number of peers"] !== undefined) {
				numPeers = parseInt(json["Number of peers"]) || 0;
				if(numPeers >= 50 && updateToolOptions.vis_simulation_active) {
					let disableNetworkVisualizer  = confirm(`You are generating ${numPeers} nodes. Would you like to disable the network visualizer for an increase in performance?`);
					if(disableNetworkVisualizer) {
						vis_toggleTopologyVisualizer();
					}
				}
			}

			generateTopology(json);
			$("#minerList option:first").prop("selected", true);
			$("#minerList option:first").change();
			updateTools();
		} catch(e) {
			alert(e);
			return;
		}
	}

	function generateTopology(options) {
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("");
		DOM_removeAllMiners();
		let miners, chosenNames, bidirectional, nPeers, minPower, maxPower, minLatency, maxLatency, names, minNumConnections, maxNumConnections, structure;
		switch(options["Type"]) {
			case "Ring":
				bidirectional = !!options["Bidirectional"];
				nPeers = options["Number of peers"] || 6;
				minPower = options["Minimum power"] || 20;
				maxPower = options["Maximum power"] || 20;
				minDownloadMBPS = options["Minimum download megabytes per second"] || 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] || 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] || 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] || 10;
				minLatency = options["Minimum latency"] || 10;
				maxLatency = options["Maximum latency"] || 100;
				names = options["Naming cycle"] || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					if(bidirectional) miners[i + 1].addConnection(miners[i].ID);
				}
				miners[miners.length - 1].addConnection(miners[0].ID);
				if(bidirectional) miners[0].addConnection(miners[miners.length - 1].ID);
				break;

			case "Mesh":
				minNumConnections = options["Minimum number of connections"] || 1;
				maxNumConnections = options["Maximum number of connections"] || 1;
				bidirectional = !!options["Bidirectional"];
				preventDuplicateConnections = !!options["Prevent duplicate connections"];
				nPeers = options["Number of peers"] || 6;
				minPower = options["Minimum power"] || 20;
				maxPower = options["Maximum power"] || 20;
				minDownloadMBPS = options["Minimum download megabytes per second"] || 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] || 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] || 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] || 10;
				minLatency = options["Minimum latency"] || 10;
				maxLatency = options["Maximum latency"] || 100;
				names = options["Naming cycle"] || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length; i++) {
					let nConnections = rnd(minNumConnections, maxNumConnections);
					for(let j = 0; j < nConnections; j++) {
						let r = rnd(0, miners.length - 1);
						// Attempt to connect to a unique connections at most 10 times
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);


						if(preventDuplicateConnections && (miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID))) continue;

						miners[i].addConnection(miners[r].ID);
						if(bidirectional) miners[r].addConnection(miners[i].ID);
					}
				}
				break;

			case "Star":
				towardsCenter = !!options["Towards center (if bidirectional=false)"];
				bidirectional = !!options["Bidirectional"];
				nPeers = options["Number of peers"] || 6;
				minPower = options["Minimum power"] || 20;
				maxPower = options["Maximum power"] || 20;
				minDownloadMBPS = options["Minimum download megabytes per second"] || 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] || 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] || 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] || 10;
				minLatency = options["Minimum latency"] || 10;
				maxLatency = options["Maximum latency"] || 100;
				names = options["Naming cycle"] || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				if(bidirectional) {
					for(let i = 1; i < miners.length; i++) {
						miners[i].addConnection(miners[0].ID);
						miners[0].addConnection(miners[i].ID);
					}
				} else if(towardsCenter) {
					for(let i = 1; i < miners.length; i++) {
						miners[i].addConnection(miners[0].ID);
					}
				} else {
					for(let i = 1; i < miners.length; i++) {
						miners[0].addConnection(miners[i].ID);
					}
				}
				break;

			case "Fully Connected":
				nPeers = options["Number of peers"] || 4;
				minPower = options["Minimum power"] || 20;
				maxPower = options["Maximum power"] || 20;
				minDownloadMBPS = options["Minimum download megabytes per second"] || 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] || 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] || 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] || 10;
				minLatency = options["Minimum latency"] || 10;
				maxLatency = options["Maximum latency"] || 100;
				names = options["Naming cycle"] || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length; i++) {
					for(let j = 0; j < miners.length; j++) {
						miners[i].addConnection(miners[j].ID);
						miners[j].addConnection(miners[i].ID);
					}
				}
				break;
			case "Line":
				bidirectional = !!options["Bidirectional"];
				nPeers = options["Number of peers"] || 6;
				minPower = options["Minimum power"] || 20;
				maxPower = options["Maximum power"] || 20;
				minDownloadMBPS = options["Minimum download megabytes per second"] || 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] || 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] || 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] || 10;
				minLatency = options["Minimum latency"] || 10;
				maxLatency = options["Maximum latency"] || 100;
				names = options["Naming cycle"] || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					if(bidirectional) miners[i + 1].addConnection(miners[i].ID);
				}
				break;
			case "Tree":
				bidirectional = !!options["Bidirectional"];
				structure = options["Structure"];
				minPower = options["Minimum power"] || 20;
				maxPower = options["Maximum power"] || 20;
				minDownloadMBPS = options["Minimum download megabytes per second"] || 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] || 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] || 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] || 10;
				minLatency = options["Minimum latency"] || 10;
				maxLatency = options["Maximum latency"] || 100;
				names = options["Naming cycle"] || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				chosenNames = [];
				let i = 0;
				recursivelyGenerateTreeTopology(structure, null);
				function recursivelyGenerateTreeTopology(structure, parent) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					let miner = newMiner(name, power, latency, downloadMBPS, uploadMBPS, true);
					if(parent != null) {
						if(bidirectional) {
							miner.addConnection(parent.ID);
							parent.addConnection(miner.ID);
						} else {
							miner.addConnection(parent.ID);
						}
					}
					for(let child of structure) {
						i++;
						recursivelyGenerateTreeTopology(child, miner, i);
					}
				}
				break;
			case "Bus":
				nPeers = options["Number of peers"] || 6;
				minPower = options["Minimum power"] || 20;
				maxPower = options["Maximum power"] || 20;
				minDownloadMBPS = options["Minimum download megabytes per second"] || 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] || 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] || 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] || 10;
				minLatency = options["Minimum latency"] || 10;
				maxLatency = options["Maximum latency"] || 100;
				names = options["Naming cycle"] || ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					miners[i + 1].addConnection(miners[i].ID);
				}
				break;
			default:
				$("#addMinerBadge").attr("class", "badge badge-danger");
				$("#addMinerBadge").text("UNEXPECTED TOPOLOGY");
		}
		DOM_selectedMiner();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_setNetworkDifficulty() {
		const difficulty = prompt("Enter a network difficulty threshhold in hex, or in decimal (as the probability of finding a block).\n\nEasiest difficulty = 1.0 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", network.difficulty);
		if(difficulty == null) return;
		network.setDifficulty(difficulty);
		alert("Difficulty has been set to " + network.difficulty * 100 + "% chance of a nonce being a block.");
	}

	function toggleSha256() {
		if(network.useSHA256) {
			network.useSHA256 = false;
			$("#useSHA256Btn").text("Use secure SHA-256 (slower)");
			alert("Using real security (SHA-256) has been disabled.");
		} else {
			network.useSHA256 = true;
			$("#useSHA256Btn").text("Use fast block verification");
			alert("Using real security (SHA-256) has been enabled.");
		}
	}

	function DOM_setBlockSizes() {
		try {
			const blockSize = prompt("Enter a block size in bytes", network.blockSize);
			let size = parseInt(blockSize);
			if(size > 0) {
				network.blockSize = size;
				alert("The block size has been updated to " + size + " bytes.");
			}
		} catch(e) {}
	}

	function DOM_toggleMining() {
		const e = $("#minerList option:selected");
		const miner = network.peers[e.val()];
		if(miner === undefined) {
			$("#addMinerBadge").attr("class", "badge badge-warning");
			$("#addMinerBadge").text("NO MINER SELECTED");
		} else {
			if(network.miningThreads[miner.ID] !== undefined) {
				miner.stopMining();
			} else {
				miner.startMining();
				$("#toggleMiningBtn").text("Stop All Miners");
			}
		}
	}

	function DOM_toggleAllMining() {
		if($("#toggleMiningBtn").text() == "Start All Miners") {
			$("#toggleMiningBtn").text("Stop All Miners");
			network.startAllMiners();
			$("#toggleMiningBtn").attr("class", "btn btn-warning rounded-0 border border-top-0 border-dark");
		} else {
			$("#toggleMiningBtn").text("Start All Miners");
			network.stopAllMiners();
			$("#toggleMiningBtn").attr("class", "btn btn-dark rounded-0");
		}
	}

	function DOM_toggleMinerStatsTable() {
		let minerStatsDiv = document.getElementById("minerStatsDiv");
		if(updateToolOptions.minerStatsTable_active) {
			updateToolOptions.minerStatsTable_active = false;
			$("#minerStatsTable").html("");
			$("#minerStatsDiv").hide();
		} else {
			updateToolOptions.minerStatsTable_active = true;
			updateMinerStatsTable();
			$("#minerStatsDiv").show();
		}
	}

	function updateMinerStatsTable() {
		let html = "<thead>";
		html += "<th scope='col'><button onclick='updateMinerStatsTable()' class='btn btn-secondary'>Refresh</button></th>";
		html += "<th scope='col'>Account balance</th>";
		html += "<th scope='col' class='text-warning'>%</th>";
		html += "<th scope='col'>Power (H/s)</th>";
		html += "<th scope='col' class='text-warning'>%</th>";

		if(network.logging.logNetworkData) {
			html += "<th scope='col'>Num hops</th>";
			html += "<th scope='col'>Block delay</th>";
		}

		html += "<th scope='col'>Latency (ms)</th>";
		html += "<th scope='col' class='text-warning'>%</th>";
		html += "<th scope='col'>Download rate (mbps)</th>";
		html += "<th scope='col' class='text-warning'>%</th>";
		html += "<th scope='col'>Upload rate (mbps)</th>";
		html += "<th scope='col' class='text-warning'>%</th>";
		html += "<th scope='col'>In peers</th>";
		html += "<th scope='col'>Out peers</th>";
		html += "<th scope='col'>Block height</th>";
		html += "<th scope='col'>Total blocks found</th>";
		html += "<th scope='col'>Stale blocks found</th>";
		html += "<th scope='col'>Max fork length</th>";
		html += "</thead>";
		html += "<tbody>";
		let sum = {
			power: 0,
			numHops: 0,
			blockDelay: 0,
			latency: 0,
			downloadMBPS: 0,
			uploadMBPS: 0,
			balance: 0,
			incomingPeers: 0,
			outgoingPeers: 0,
			height: 0,
			totalBlocksFound: 0,
			staleBlocksFound: 0,
			largestForkLength: 0
		}
		let avg = {
			power: 0,
			numHops: 0,
			blockDelay: 0,
			latency: 0,
			downloadMBPS: 0,
			uploadMBPS: 0,
			balance: 0,
			incomingPeers: 0,
			outgoingPeers: 0,
			height: 0,
			totalBlocksFound: 0,
			staleBlocksFound: 0,
			largestForkLength: 0
		}
		let numPeers = 0;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			sum.power += miner.power;

			if(network.logging.logNetworkData) { // Keep track of networking data
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;
					sum.numHops += numHopsAvg;
					sum.blockDelay += blockDelayAvg;
				} catch(e) {}
			}

			sum.latency += miner.latency;
			sum.downloadMBPS += miner.downloadMBPS;
			sum.uploadMBPS += miner.uploadMBPS;
			sum.balance += (miner.currentHeader.balances[id] - 1);
			sum.incomingPeers += miner.incomingPeers.length;
			sum.outgoingPeers += miner.outgoingPeers.length;
			sum.height += (miner.currentHeader.height - 1);
			sum.totalBlocksFound += miner.totalBlocksFound;
			sum.staleBlocksFound += miner.staleBlocksFound;
			sum.largestForkLength += miner.largestForkLength;
			numPeers++;
		}
		avg.power = Math.floor(sum.power / numPeers * 1000) / 1000;
		if(network.logging.logNetworkData) { // Keep track of networking data
			avg.numHops = Math.floor(sum.numHops / numPeers * 1000) / 1000;
			avg.blockDelay = Math.floor(sum.blockDelay / numPeers * 1000) / 1000;
		}
		avg.latency = Math.floor(sum.latency / numPeers * 1000) / 1000;
		avg.downloadMBPS = Math.floor(sum.downloadMBPS / numPeers * 1000) / 1000;
		avg.uploadMBPS = Math.floor(sum.uploadMBPS / numPeers * 1000) / 1000;
		avg.balance = Math.floor(sum.balance / numPeers * 1000) / 1000;
		avg.incomingPeers = Math.floor(sum.incomingPeers / numPeers * 1000) / 1000;
		avg.outgoingPeers = Math.floor(sum.outgoingPeers / numPeers * 1000) / 1000;
		avg.height = Math.floor(sum.height / numPeers * 1000) / 1000;
		avg.totalBlocksFound = Math.floor(sum.totalBlocksFound / numPeers * 1000) / 1000;
		avg.staleBlocksFound = Math.floor(sum.staleBlocksFound / numPeers * 1000) / 1000;
		avg.largestForkLength = Math.floor(sum.largestForkLength / numPeers * 1000) / 1000;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			html += "<tr onclick='selectMiner(\"" + miner.ID + "\")'>";
			html += "<th scope='col'>" + miner.name + "</th>";
			html += "<th scope='col'>" + (miner.currentHeader.balances[id] - 1) + " BTC</th>";
			html += "<th scope='col' class='text-warning'>" + (Math.floor((miner.currentHeader.balances[id] - 1) / sum.balance * 100000) / 1000 || 0) + "</th>";
			html += "<th scope='col'>" + miner.power + "</th>";
			html += "<th scope='col' class='text-warning'>" + (Math.floor(miner.power / sum.power * 100000) / 1000) + "</th>";

			if(network.logging.logNetworkData) { // Keep track of networking data
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;

					html += "<th scope='col'>" + (Math.floor(numHopsAvg * 1000) / 1000) + "</th>";
					html += "<th scope='col'>" + (Math.floor(blockDelayAvg * 1000) / 1000) + "</th>";
				} catch(e) {
					html += "<th scope='col'></th>";
					html += "<th scope='col'></th>";
				}
			}

			html += "<th scope='col'>" + miner.latency + "</th>";
			html += "<th scope='col' class='text-warning'>" + (Math.floor(miner.latency / sum.latency * 100000) / 1000) + "</th>";

			html += "<th scope='col'>" + miner.downloadMBPS + "</th>";
			html += "<th scope='col' class='text-warning'>" + (Math.floor(miner.downloadMBPS / sum.downloadMBPS * 100000) / 1000) + "</th>";

			html += "<th scope='col'>" + miner.uploadMBPS + "</th>";
			html += "<th scope='col' class='text-warning'>" + (Math.floor(miner.uploadMBPS / sum.uploadMBPS * 100000) / 1000) + "</th>";

			html += "<th scope='col'>" + miner.incomingPeers.length + "</th>";
			html += "<th scope='col'>" + miner.outgoingPeers.length + "</th>";
			html += "<th scope='col'>" + (miner.currentHeader.height - 1) + "</th>";
			html += "<th scope='col'>" + miner.totalBlocksFound + "</th>";
			html += "<th scope='col'>" + miner.staleBlocksFound + "</th>";
			html += "<th scope='col'>" + miner.largestForkLength + "</th>";
			html += "</tr>";
		}
		html += "<tr class='text-dark bg-light'>";
		html += "<th scope='col'>Sum<br>Average</th>";
		html += "<th scope='col'>" + sum.balance + "<br>" + avg.balance + "</th>";
		html += "<th scope='col'></th>";
		html += "<th scope='col'>" + sum.power + "<br>" + avg.power + "</th>";
		html += "<th scope='col'></th>";

		if(network.logging.logNetworkData) { // Keep track of networking data
			html += "<th scope='col'>" + (Math.floor(sum.numHops * 1000) / 1000) + "<br>" + (Math.floor(avg.numHops * 1000) / 1000) + "</th>";
			html += "<th scope='col'>" + (Math.floor(sum.blockDelay * 1000) / 1000) + "<br>" + (Math.floor(avg.blockDelay * 1000) / 1000) + "</th>";
		}

		html += "<th scope='col'>" + sum.latency + "<br>" + avg.latency + "</th>";
		html += "<th scope='col'></th>";
		html += "<th scope='col'>" + sum.downloadMBPS + "<br>" + avg.downloadMBPS + "</th>";
		html += "<th scope='col'></th>";
		html += "<th scope='col'>" + sum.uploadMBPS + "<br>" + avg.uploadMBPS + "</th>";
		html += "<th scope='col'></th>";
		html += "<th scope='col'>" + sum.incomingPeers + "<br>" + avg.incomingPeers + "</th>";
		html += "<th scope='col'>" + sum.outgoingPeers + "<br>" + avg.outgoingPeers + "</th>";
		html += "<th scope='col'><br>" + avg.height + "</th>";
		html += "<th scope='col'>" + sum.totalBlocksFound + "<br>" + avg.totalBlocksFound + "</th>";
		html += "<th scope='col'>" + sum.staleBlocksFound + "<br>" + avg.staleBlocksFound + "</th>";
		html += "<th scope='col'><br>" + avg.largestForkLength + "</th>";
		html += "</tr>";

		html += "</tbody>";
		$("#minerStatsTable").html(html);
	}

	function vis_toggleTopologyVisualizer() {
		let vis_container = document.getElementById("mynetwork");
		if(updateToolOptions.vis_simulation_active) {
			updateToolOptions.vis_simulation_active = false;
			vis_clearNetworkSimulation();
			$("#vis_refresh_btn").hide();
			$("#vis_line_length_btn").hide();
			$("#vis_btn_delimeter").hide();
		} else {
			updateToolOptions.vis_simulation_active = true;
			updateToolOptions.vis_timeout = null;
			vis_container.style.height = "500px";
			vis_container.style.opacity = "1";
			vis_setupNetworkSimulation();
			$("#vis_refresh_btn").show();
			$("#vis_line_length_btn").show();
			$("#vis_btn_delimeter").show();
		}
	}

	function vis_clearNetworkSimulation() {
		let vis_container = document.getElementById("mynetwork");
		updateToolOptions.vis_nodeIDs = []
		updateToolOptions.vis_network = new vis.Network(vis_container, {}, {});
		vis_container.innerHTML = "";
		vis_container.style.height = "0";
		vis_container.style.opacity = "0";
	}

	function vis_setLineLengths() {
		let length_s = prompt("How long should lines be?")
		if(length_s == null) return;
		let length = parseInt(length_s) || undefined;

		updateToolOptions.vis_lineLength = length;
		vis_setupNetworkSimulation();
	}

	function vis_setupNetworkSimulation() {
		// Wait a minimum time before allowing the next simulation setup
		if(updateToolOptions.vis_timeout != null) return;
		updateToolOptions.vis_timeout = setTimeout(_vis_setupNetworkSimulation, 510);
	}

	function _vis_setupNetworkSimulation() {
		updateToolOptions.vis_nodeIDs = []
		let vis_nodes = [], vis_edges = [], i = 0;
		for(let id in network.ID_Registry) {
			updateToolOptions.vis_nodeIDs[id] = i;
			vis_nodes.push({
				id: updateToolOptions.vis_nodeIDs[id],
				label: network.peers[id].name,
				group: i,
				color: network.peers[id].color == "default" ? undefined : network.peers[id].color,
			});
			i++;
		}

		for(let id1 in network.ID_Registry) {
			for(let id2 of network.peers[id1].outgoingPeers) {
				vis_edges.push({
					from: updateToolOptions.vis_nodeIDs[id1],
					to: updateToolOptions.vis_nodeIDs[id2],
					length: updateToolOptions.vis_lineLength,
					// Add dashes to lines that are not bi-directional connections
					// dashes: network.peers[id2].outgoingPeers.includes(id1) ? false : [10, 10],
				});
			}
		}
		let vis_container = document.getElementById("mynetwork");

		updateToolOptions.vis_network_options = {
			nodes: {
				shape: "dot",
				size: 30,
				font: {
					size: 32,
					color: "#FFF"
				},
				borderWidth: 4,
			},
			edges: {
				width: 6
			},
			layout: {
				improvedLayout: false
			},
			interaction:{
				dragView: false,
				selectConnectedEdges: false,
				zoomView: false
			}
		};

		updateToolOptions.vis_network = new vis.Network(vis_container, {
			nodes: vis_nodes,
			edges: vis_edges
		}, updateToolOptions.vis_network_options);

		// Retrieve the node color from the vis.js datastructure
		let vis_rawNodeData = updateToolOptions.vis_network.nodesHandler.body.nodes;
		let style = "";
		for(let id in updateToolOptions.vis_nodeIDs) {
			try {
				let vis_rawNode = vis_rawNodeData[updateToolOptions.vis_nodeIDs[id]];
				let color = vis_rawNode.options.color.background;
				network.peers[id].color = color;
				style += "#minerList option:checked[value=\"" + id + "\"]{border-right:20px solid " + color + ";padding-left:10px}";
			} catch(e) {}
		}
		document.getElementById("miner-colors-selector").innerHTML = style;

		updateMinerJsonEditor();

		updateToolOptions.vis_network.on("selectNode", function (params) {
			let miner, minerID;
			for(let id in updateToolOptions.vis_nodeIDs) {
				if(updateToolOptions.vis_nodeIDs[id] == params.nodes[0]) {
					minerID = id;
				}
			}
			selectMiner(minerID);
		});
		updateToolOptions.vis_timeout = null;
	}

	// Save the code from the DOM to the network data
	function saveSamplerSettings() {

		network.logging.msPerSample = Math.floor(Number($("#timePerSample").val()) * 1000);

		// Add the code wrapper
		let _code = "let numSamples = updateToolOptions.numSamples, samplerData = updateToolOptions.samplerData;\nfunction setTag(tag) {\n\tupdateToolOptions.sampleTag = tag.toString();\n}\n\n";

		network.logging.codeBeforeSampling = "{\n" + _code + $("#codeBeforeSampling").val() + "\n}";
		network.logging.codeBetweenSamples = "{\n" + _code + $("#codeBetweenSamples").val() + "\n}";
		network.logging.codeAfterSampling = "{\n" + _code + $("#codeAfterSampling").val() + "\n}";

		network.logging.logSamples = $("#logSamplesCheckbox").prop("checked");
		network.logging.resetBlockchainAfterEachSample = $("#resetBlockchainAfterEachSampleCheckbox").prop("checked");
		network.logging.updateTableAfterEachSample = $("#updateTableAfterEachSampleCheckbox").prop("checked");
	}

	// Load the code from the network to the DOM
	function loadSamplerSettings() {
		$("#timePerSample").val(network.logging.msPerSample / 1000);

		// Remove the code wrapper
		let _code = "let numSamples = updateToolOptions.numSamples, samplerData = updateToolOptions.samplerData;\nfunction setTag(tag) {\n\tupdateToolOptions.sampleTag = tag.toString();\n}\n\n";

		let codeBeforeSampling = network.logging.codeBeforeSampling;
		let codeBetweenSamples = network.logging.codeBetweenSamples;
		let codeAfterSampling = network.logging.codeAfterSampling;

		if(codeBeforeSampling.startsWith('{\n')) codeBeforeSampling = codeBeforeSampling.substring(2);
		if(codeBetweenSamples.startsWith('{\n')) codeBetweenSamples = codeBetweenSamples.substring(2);
		if(codeAfterSampling.startsWith('{\n')) codeAfterSampling = codeAfterSampling.substring(2);

		if(codeBeforeSampling.startsWith(_code)) codeBeforeSampling = codeBeforeSampling.substring(_code.length);
		if(codeBetweenSamples.startsWith(_code)) codeBetweenSamples = codeBetweenSamples.substring(_code.length);
		if(codeAfterSampling.startsWith(_code)) codeAfterSampling = codeAfterSampling.substring(_code.length);

		if(codeBeforeSampling.endsWith('\n}')) codeBeforeSampling = codeBeforeSampling.slice(0, -2);
		if(codeBetweenSamples.endsWith('\n}')) codeBetweenSamples = codeBetweenSamples.slice(0, -2);
		if(codeAfterSampling.endsWith('\n}')) codeAfterSampling = codeAfterSampling.slice(0, -2);

		$("#codeBeforeSampling").val(codeBeforeSampling);
		$("#codeBetweenSamples").val(codeBetweenSamples);
		$("#codeAfterSampling").val(codeAfterSampling);

		$("#logSamplesCheckbox").prop("checked", network.logging.logSamples);
		$("#resetBlockchainAfterEachSampleCheckbox").prop("checked", network.logging.resetBlockchainAfterEachSample);
		$("#updateTableAfterEachSampleCheckbox").prop("checked", network.logging.updateTableAfterEachSample);
	}

	function DOM_toggleSamplerForm() {
		if(updateToolOptions.sampler_DOM_active) {
			$("#samplerDiv").hide();
			updateToolOptions.sampler_DOM_active = false;
		} else {
			$("#samplerDiv").show();
			updateToolOptions.sampler_DOM_active = true;
		}
	}

	function toggleSampling(override) {
		if(override !== undefined) updateToolOptions.sampler_running = !override;
		if(updateToolOptions.sampler_running) {
			stopSampling();
			$("#toggleSamplingBtn").text("Begin Sampling");
			$("#toggleSamplingBtn").attr("class", "btn btn-primary fillx border border-dark");
			updateToolOptions.sampler_running = false;
			updateSamplerTable();
		} else {
			initSampler();
			$("#toggleSamplingBtn").text("Stop Sampling");
			$("#toggleSamplingBtn").attr("class", "btn btn-warning fillx border border-dark");
			updateToolOptions.sampler_running = true;
			network.startAllMiners();
			updateToolOptions.sampleStartTime = new Date().getTime();
			setTimeout(sample, network.logging.msPerSample);
		}
	}

	function initSampler() {
		network.stopAllMiners();
		network.clearBlockchain();
		updateToolOptions.numSamples = 0;
		updateToolOptions.samplerData = [];
		updateToolOptions.samplerLog = ["Sample,Sample Time,Sample Tag"];
		updateToolOptions.sampleTag = "";


		if(updateToolOptions.vis_simulation_active) {
			console.info("Disabling the topology visualizer for more precise measurements.");
			console.info("This can be re-enabled by clicking the dropdown above the table and selecting \"Toggle topology visualizer\".");
			vis_toggleTopologyVisualizer();
		}

		for(let id in network.ID_Registry) {
			updateToolOptions.samplerLog[0] += ",Name,Balance,Balance %,Power,Power %,"

			if(network.logging.logNetworkData) { // Keep track of networking data
				updateToolOptions.samplerLog[0] += "Num Hops,";
				updateToolOptions.samplerLog[0] += "Block Delay,";
			}

			updateToolOptions.samplerLog[0] += "Latency,Latency %,Download MBPS,Download MBPS %,Upload MBPS,Upload MBPS %,Block Height,Total Blocks Found,Stale Blocks Found,Max Fork Length";
			updateToolOptions.samplerData[id] = {
				sumBalance: 0,
				sumPower: 0,
				sumNumHops: 0,
				sumBlockDelay: 0,
				sumLatency: 0,
				sumDownloadMBPS: 0,
				sumUploadMBPS: 0,
				sumBlockHeight: 0,
				sumTotalBlocks: 0,
				sumStaleBlocks: 0,
				sumMaxForkLength: 0
			}
		}

		saveSamplerSettings();
		
		// Convert miner IDs into proper references
		for(let id in network.ID_Registry) {
			const r = new RegExp("([^A-z0-9_])" + id + "([^A-z0-9_])", "gi");
			network.logging.codeBeforeSampling = network.logging.codeBeforeSampling.replace(r, "$1network.peers[\"" + id + "\"]$2");
			network.logging.codeBetweenSamples = network.logging.codeBetweenSamples.replace(r, "$1network.peers[\"" + id + "\"]$2");
			network.logging.codeAfterSampling = network.logging.codeAfterSampling.replace(r, "$1network.peers[\"" + id + "\"]$2");
		}
		try {
			eval(network.logging.codeBeforeSampling);
		} catch(e) {
			alert(e);
			console.warn(e);
		}
	}

	function sample() {
		updateToolOptions.sampleEndTime = new Date().getTime();

		if(network.logging.resetBlockchainAfterEachSample) {
			network.stopAllMiners();
		}


		let sampleDuration = (updateToolOptions.sampleEndTime - updateToolOptions.sampleStartTime) / 1000;
		updateToolOptions.numSamples++;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			updateToolOptions.samplerData[id].sumBalance += miner.currentHeader.balances[id];
			updateToolOptions.samplerData[id].sumPower += miner.power;

			if(network.logging.logNetworkData) {
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;
					updateToolOptions.samplerData[id].sumNumHops += numHopsAvg;
					updateToolOptions.samplerData[id].sumBlockDelay += blockDelayAvg;
				} catch(e) {}
			}

			updateToolOptions.samplerData[id].sumLatency += miner.latency;
			updateToolOptions.samplerData[id].sumDownloadMBPS += miner.downloadMBPS;
			updateToolOptions.samplerData[id].sumUploadMBPS += miner.uploadMBPS;
			updateToolOptions.samplerData[id].sumBlockHeight += miner.currentHeader.height - 1;
			updateToolOptions.samplerData[id].sumTotalBlocks += miner.totalBlocksFound;
			updateToolOptions.samplerData[id].sumStaleBlocks += miner.staleBlocksFound;
			updateToolOptions.samplerData[id].sumMaxForkLength += miner.largestForkLength;
		}
		if(network.logging.logSamples) {
			let line = "", balanceTotal = 0, powerTotal = 0, latencyTotal = 0, downloadMBPSTotal = 0, uploadMBPSTotal = 0;
			line += "\"" + updateToolOptions.samplerLog.length + "\",";
			line += "\"" + sampleDuration + "\",";
			line += "\"" + updateToolOptions.sampleTag + "\",";

			for(let id in network.ID_Registry) {
				let miner = network.peers[id];
				balanceTotal += miner.currentHeader.balances[id];
				powerTotal += miner.power;
				latencyTotal += miner.latency;
				downloadMBPSTotal += miner.downloadMBPS;
				uploadMBPSTotal += miner.uploadMBPS;
			}
			for(let id in network.ID_Registry) {
				let miner = network.peers[id];
				line += "\"" + miner.name + "\",";
				line += "\"" + miner.currentHeader.balances[id] + "\",";
				line += "\"" + (miner.currentHeader.balances[id] / balanceTotal * 100) + "\",";
				line += "\"" + miner.power + "\",";
				line += "\"" + (miner.power / powerTotal * 100) + "\",";

				if(network.logging.logNetworkData) { // Keep track of networking data
					try {
						line += "\"" + miner.blockchain_numHops.join(" ") + "\",";
						line += "\"" + miner.blockchain_blockDelay.join(" ") + "\",";
					} catch(e) {}
				}

				line += "\"" + miner.latency + "\",";
				line += "\"" + (miner.latency / latencyTotal * 100) + "\",";
				line += "\"" + miner.downloadMBPS + "\",";
				line += "\"" + (miner.downloadMBPS / downloadMBPSTotal * 100) + "\",";
				line += "\"" + miner.uploadMBPS + "\",";
				line += "\"" + (miner.uploadMBPS / uploadMBPSTotal * 100) + "\",";
				line += "\"" + (miner.currentHeader.height - 1) + "\",";
				line += "\"" + miner.totalBlocksFound + "\",";
				line += "\"" + miner.staleBlocksFound + "\",";
				line += "\"" + miner.largestForkLength + "\",";
			}
			updateToolOptions.samplerLog.push(line);
		}
		if(network.logging.resetBlockchainAfterEachSample) {
			network.clearBlockchain();
		}

		if(network.logging.updateTableAfterEachSample) {
			updateSamplerTable();
		}
		try {
			eval(network.logging.codeBetweenSamples);
		} catch(e) {
			alert(e);
			console.warn(e);
			stopSampling();
			return;
		}

		if(network.logging.resetBlockchainAfterEachSample) {
			network.startAllMiners();
		}
		if(updateToolOptions.sampler_running) {
			updateToolOptions.sampleStartTime = new Date().getTime();
			setTimeout(sample, network.logging.msPerSample);
		}
	}

	function stopSampling() {
		try {
			eval(network.logging.codeAfterSampling);
		} catch(e) {
			alert(e);
			console.warn(e);
		}
		network.stopAllMiners();
		network.clearBlockchain();
	}

	function updateSamplerTable() {
		let sampleDuration = (updateToolOptions.sampleEndTime - updateToolOptions.sampleStartTime) / 1000;
		let html = "<thead><th colspan='8'><span class='text-warning lead'>" + updateToolOptions.numSamples + (updateToolOptions.numSamples == 1 ? " sample" : " samples") + " taken"
		if(updateToolOptions.sampler_running) html += " (" + sampleDuration + " seconds)";
		if(updateToolOptions.sampleTag.length > 0) html += " (" + updateToolOptions.sampleTag + ")";
		html += "</span>";
		if(updateToolOptions.samplerLog.length > 1) html += "</th><th colspan='3'><button onclick='downloadSampleLog()' class='btn btn-warning fillx'>Download log</button></th>";
		html += "</thead><thead>";
		html += "<th scope='col'></th>";
		html += "<th scope='col'>Average<br>account balance</th>";
		html += "<th scope='col' class='text-warning'>%</th>";
		html += "<th scope='col'>Average<br>power (H/s)</th>";

		if(network.logging.logNetworkData) { // Keep track of networking data
			html += "<th scope='col'>Average<br>num hops</th>";
			html += "<th scope='col'>Average<br>block delay</th>";
		}

		html += "<th scope='col'>Average<br>latency (ms)</th>";
		html += "<th scope='col'>Average<br>download MBPS</th>";
		html += "<th scope='col'>Average<br>upload MBPS</th>";
		html += "<th scope='col'>Average<br>block height</th>";
		html += "<th scope='col'>Average<br>total blocks found</th>";
		html += "<th scope='col'>Average<br>stale blocks found</th>";
		html += "<th scope='col'>Average<br>max fork length</th>";
		html += "</thead>";
		html += "<tbody>";
		let miner, avgSumBalance, percentAvgSumBalance, miners = 0, sumAvgSumBalance = 0, avgPower, avgNumHops, avgBlockDelay, avgLatency, avgDownloadMBPS, avgUploadMBPS, avgBlockHeight, avgTotalBlocks, avgStaleBlocks, avgMaxForkLength;
		

		for(let id in network.ID_Registry) {
			miners++;
			sumAvgSumBalance += updateToolOptions.samplerData[id].sumBalance / updateToolOptions.numSamples;
		}

		for(let id in network.ID_Registry) {
			miner = network.peers[id];
			avgSumBalance = Math.floor(updateToolOptions.samplerData[id].sumBalance / updateToolOptions.numSamples * 1000) / 1000;
			percentAvgSumBalance = Math.floor(avgSumBalance / sumAvgSumBalance * 100000) / 1000;
			avgPower = Math.floor(updateToolOptions.samplerData[id].sumPower / updateToolOptions.numSamples * 1000) / 1000;
			if(network.logging.logNetworkData) { // Keep track of networking data
				avgNumHops = Math.floor(updateToolOptions.samplerData[id].sumNumHops / updateToolOptions.numSamples * 1000) / 1000;
				avgBlockDelay = Math.floor(updateToolOptions.samplerData[id].sumBlockDelay / updateToolOptions.numSamples * 1000) / 1000;
			}
			avgLatency = Math.floor(updateToolOptions.samplerData[id].sumLatency / updateToolOptions.numSamples * 1000) / 1000;
			avgDownloadMBPS = Math.floor(updateToolOptions.samplerData[id].sumDownloadMBPS / updateToolOptions.numSamples * 1000) / 1000;
			avgUploadMBPS = Math.floor(updateToolOptions.samplerData[id].sumUploadMBPS / updateToolOptions.numSamples * 1000) / 1000;
			avgBlockHeight = Math.floor(updateToolOptions.samplerData[id].sumBlockHeight / updateToolOptions.numSamples * 1000) / 1000;
			avgTotalBlocks = Math.floor(updateToolOptions.samplerData[id].sumTotalBlocks / updateToolOptions.numSamples * 1000) / 1000;
			avgStaleBlocks = Math.floor(updateToolOptions.samplerData[id].sumStaleBlocks / updateToolOptions.numSamples * 1000) / 1000;
			avgMaxForkLength = Math.floor(updateToolOptions.samplerData[id].sumMaxForkLength / updateToolOptions.numSamples * 1000) / 1000;
			html += "<tr onclick='selectMiner(\"" + miner.ID + "\")'>";
			html += "<th scope='col'>" + miner.name + "</th>";
			html += "<th scope='col'>" + avgSumBalance + " BTC</th>";
			html += "<th scope='col' class='text-warning'>" + percentAvgSumBalance + "</th>";
			html += "<th scope='col'>" + avgPower + "</th>";

			if(network.logging.logNetworkData) { // Keep track of networking data
				html += "<th scope='col'>" + avgNumHops + "</th>";
				html += "<th scope='col'>" + avgBlockDelay + "</th>";
			}

			html += "<th scope='col'>" + avgLatency + "</th>";
			html += "<th scope='col'>" + avgDownloadMBPS + "</th>";
			html += "<th scope='col'>" + avgUploadMBPS + "</th>";
			html += "<th scope='col'>" + avgBlockHeight + "</th>";
			html += "<th scope='col'>" + avgTotalBlocks + "</th>";
			html += "<th scope='col'>" + avgStaleBlocks + "</th>";
			html += "<th scope='col'>" + avgMaxForkLength + "</th>";
			html += "</tr>";
		}
		html += "</tbody>";
		$("#sampleTable").html(html);
		if(updateToolOptions.minerStatsTable_active) updateMinerStatsTable();
	}

	function downloadSampleLog(name = "PoW_log.csv") {
		// Confidence interval
		// =CONFIDENCE(0.05, STDEV(A2:A21), COUNT(A2:A21))
		let log = updateToolOptions.samplerLog.join("\r\n");
		let a=document.createElement("a");
		a.setAttribute("href","data:text/plain;charset=utf-8,"+encodeURIComponent(log));
		a.setAttribute("download", name);
		a.click();
	}

	// Canvas2SVG initialization
	// ["custom", "ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]

	C2S.prototype.dot = CanvasRenderingContext2D.prototype.dot;

	C2S.prototype.circle = CanvasRenderingContext2D.prototype.circle;
	C2S.prototype.dashedLine = CanvasRenderingContext2D.prototype.dashedLine;
	C2S.prototype.database = CanvasRenderingContext2D.prototype.database;
	C2S.prototype.diamond = CanvasRenderingContext2D.prototype.diamond;
	C2S.prototype.ellipse = CanvasRenderingContext2D.prototype.ellipse;
	C2S.prototype.ellipse_vis = CanvasRenderingContext2D.prototype.ellipse_vis;
	C2S.prototype.hexagon = CanvasRenderingContext2D.prototype.hexagon;
	C2S.prototype.roundRect = CanvasRenderingContext2D.prototype.roundRect;
	C2S.prototype.square = CanvasRenderingContext2D.prototype.square;
	C2S.prototype.star = CanvasRenderingContext2D.prototype.star;
	C2S.prototype.triangle = CanvasRenderingContext2D.prototype.triangle;
	C2S.prototype.triangleDown = CanvasRenderingContext2D.prototype.triangleDown;



	C2S.prototype.circle = CanvasRenderingContext2D.prototype.circle;
	C2S.prototype.square = CanvasRenderingContext2D.prototype.square;
	C2S.prototype.triangle = CanvasRenderingContext2D.prototype.triangle;
	C2S.prototype.triangleDown = CanvasRenderingContext2D.prototype.triangleDown;
	C2S.prototype.star = CanvasRenderingContext2D.prototype.star;
	C2S.prototype.diamond = CanvasRenderingContext2D.prototype.diamond;
	C2S.prototype.roundRect = CanvasRenderingContext2D.prototype.roundRect;
	C2S.prototype.ellipse_vis = CanvasRenderingContext2D.prototype.ellipse_vis;
	C2S.prototype.database = CanvasRenderingContext2D.prototype.database;
	C2S.prototype.arrowEndpoint = CanvasRenderingContext2D.prototype.arrowEndpoint;
	C2S.prototype.circleEndpoint = CanvasRenderingContext2D.prototype.circleEndpoint;
	C2S.prototype.dashedLine = CanvasRenderingContext2D.prototype.dashedLine;



	function exportSvg() {
		var networkContainer = updateToolOptions.vis_network.body.container;
		var ctx = new C2S({
			width: networkContainer.clientWidth,
			height: networkContainer.clientWidth,
			embedImages: true
		});

		var canvasProto = updateToolOptions.vis_network.canvas.__proto__;
		var currentGetContext = canvasProto.getContext;
		canvasProto.getContext = function() {
			return ctx;
		}
		/*
		updateToolOptions.vis_network_options = {
			nodes: {
				shape: "dot",
				size: 30,
				font: {
					size: 32,
					color: "#FFF"
				},
				borderWidth: 4,
			},
			edges: {
				width: 6
			},
			layout: {
				improvedLayout: false
			},
			interaction:{
				dragView: false,
				selectConnectedEdges: false,
				zoomView: false
			}
		};
		*/
		var svgOptions = {
			nodes: {
				/*shape: "dot",
				size: 30,
				font: {
					size: 32,
					color: "#FFF"
				},
				borderWidth: 4,*/

				shapeProperties: {
					interpolation: false // So images are not scaled svg will get full image
				},
				scaling: {
					label: {
						drawThreshold: 0
					}
				},
				font: {
					color: "#000000"
				}
			},
			edges: {
				scaling: {
					label: {
						drawThreshold: 0
					}
				}
			}
		};

		//updateToolOptions.vis_network.setOptions(svgOptions);
		updateToolOptions.vis_network.redraw();
		//updateToolOptions.vis_network.setOptions(updateToolOptions.vis_network_options);
		canvasProto.getContext = currentGetContext;
		ctx.waitForComplete(function() {
			var svg = ctx.getSerializedSvg();
			showSvg(svg);
		});
	}

	function showSvg(svg) {
		var svgBlob = new Blob([svg], {
			type: "image/svg+xml"
		});
		openBlob(svgBlob, "blockchain_simulator_network.svg");
	}

	function openBlob(blob, fileName) {
		if (window.navigator && window.navigator.msSaveOrOpenBlob) {

			//blobToDataURL(blob, function(dataurl){window.open(dataurl);});
			window.navigator.msSaveOrOpenBlob(blob, fileName);
		} else {
			var a = document.getElementById("blobLink");
			if (!a) {
				a = document.createElement("a");
				document.body.appendChild(a);
				a.setAttribute("id", "blobLink");
				a.style = "display: none";
			}
			var data = window.URL.createObjectURL(blob);
			a.href = data;
			a.download = fileName;
			a.click();
			setTimeout(function() {
				// For Firefox it is necessary to delay revoking the ObjectURL
				window.URL.revokeObjectURL(data);
			}, 100);
		}
	}
</script>
</html>

