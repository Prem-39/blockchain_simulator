<!DOCTYPE HTML>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<meta name="description" content="A blockchain proof-of-work simulation tool.">
		<meta name="author" content="Simeon">
		<link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon">
		<link rel="icon" href="img/favicon.ico" type="image/x-icon">
		<link rel="stylesheet" href="lib/bootstrap.min.css">
		<link href="lib/jsoneditor.min.css" rel="stylesheet" type="text/css">
		<script type="text/javascript" src="lib/vis-network.min.js"></script>
		<script type="text/javascript" src="lib/canvas2svg.js"></script>
		<script src="lib/jsoneditor.min.js"></script>
		<script src="lib/lz-string.min.js"></script>
		<title>Blockchain Simulator</title>
		<style>
			.container {
				max-width: 960px;
				-webkit-transition: height 2s; /* Safari prior 6.1 */
  				transition: height 2s;
			}
			.fillx { 
				min-width: 100%;
				width: 100%;
			}
			.filly { 
				min-height: 100%;
				height: 100%;
			}
			#minerList {
				overflow-y: auto;
			}
			#networkjsoneditor, #topologyjsoneditor {
				height: 500px;
			}
			#jsoneditor, #topologyjsoneditor, #networkjsoneditor {
				background-color: #FFF;
				width: 100%;
			}
			#canvasVisualizerCodeContainer {
				position: absolute;
				margin-left: 10px;
				top: -32px;
				transition: opacity 0.5s, height 0.5s, max-height 0.5s;
			}
			#canvasVisualizerCodeLabel {
				color: #AAA;
			}
			#canvasVisualizerCode {
				border: none;
				color: #FFF;
				overflow-x: auto;
				background-color: transparent;
				width: 300px;
			}
			#canvasVisualizerCode:focus {
				background-color: #343A40;
			}
			#canvasVisualizer, #networkVisualizer, #minerStatsTable {
				background-color: #343A40;
				transition: opacity 0.5s, height 0.5s, max-height 0.5s;
			}
			.jsoneditor-search, .jsoneditor-frame, .jsoneditor-menu, .jsoneditor-frame table tbody tr td input, option:checked {
				background-color: #343A40 !important;
				color: #FFF !important;
			}
			div .jsoneditor, div .jsoneditor-mode-form, #minerList {
				border-color: #343A40;
				border-radius: 0;
			}
			.jsoneditor-menu { border-bottom: 0 !important; }
			.jsoneditor-text { color: #FFF; }
		</style>
		<style id="miner-colors-selector"></style>
	</head>

<body class="bg-dark py-3">
	<div class="container bg-light rounded pb-3">
		<div class="py-2 text-center">
			<h1 class="display-4 d-inline">Blockchain Simulator</h1> <span class="badge badge-primary">v1.0</span> <span class="badge badge-secondary"><a class="text-white" href="index_v0.12.html">v0.12 can be found here</a></span>
		</div>
		<div class="jumbotron p-3 mb-3">
			<div class="row">
				<div class="col-md-4">
					<div class="row px-3">
						<div class="btn-group fillx" style="max-height: 35px; cursor: pointer">
							<!-- Options -->
							<button type="button" class="btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" onclick="$('#addMinerBadge').text('')" style="width: 100%">
								<span class="sr-only">Toggle Dropdown</span>
								<span id="addMinerBadge" class="badge badge-light"></span>
								Options
							</button>
							<div class="dropdown-menu">
								<a class="dropdown-item" data-toggle="modal" data-target="#addMinerModal" onclick="addMinerBtnClicked()">Add/Edit miner</a>
								<a id="removeMinerBtn" class="dropdown-item" onclick="DOM_removeMiner()">Remove miner</a>
								<a class="dropdown-item" onclick="if(confirm('You\'re about to remove all miners.')) DOM_removeAllMiners()">Remove all miners</a>
								<a class="dropdown-item" onclick="DOM_sortMiners()">Sort miners</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" data-toggle="modal" data-target="#generateTopologyModal"><b>Generate a topology</b></a>
								<a class="dropdown-item" onclick="duplicateTopology()">Duplicate current topology</a>
								<a class="dropdown-item" onclick="regenerateTopology()">Regenerate current topology</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="DOM_toggleLoggingNetworkData()" id="DOM_item_toggleLoggingNetworkData">Enable logging network<br>data within each miner</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="DOM_globalSetPower()">Globally set power</a>
								<a class="dropdown-item" onclick="DOM_globalSetLatency()">Globally set latency</a>
								<a class="dropdown-item" onclick="DOM_globalSetDownloadMBPS()">Globally set download MBPS</a>
								<a class="dropdown-item" onclick="DOM_globalSetUploadMBPS()">Globally set upload MBPS</a>
								<a class="dropdown-item" onclick="bidirectionallyConnectPeers()">Connect bi-directionally</a>
								<a class="dropdown-item" onclick="fullyConnectPeers()">Connect all peers</a>
								<a class="dropdown-item" onclick="fullyDisconnectPeers()">Disconnect all peers</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="saveLocalStorage()">Save network to LocalStorage</a>
								<a class="dropdown-item" onclick="loadLocalStorage()">Load network from LocalStorage</a>
								<a class="dropdown-item" onclick="deleteLocalStorage()">Delete network from LocalStorage</a>
								<a class="dropdown-item" onclick="clearAllLocalStorage()">Clear all LocalStorage</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="saveToFile(true)">Save network to File</a>
								<a class="dropdown-item" onclick="saveToFile(false)">Save (uncompressed)</a>
								<a class="dropdown-item" onclick="loadFromFile()">Load network from File</a>
							</div>
						</div>
					</div>
					<div class="row px-3" style="height: calc(100% - 70px)">
						<select id="minerList" onclick="DOM_selectedMiner()" onchange="DOM_selectedMiner()" size="6" class="form-control fillx filly">
						</select>
					</div>
					<div class="row px-3">
						<div class="btn-group fillx" style="max-height: 35px; cursor: pointer">
							<button id="toggleMiningBtn" onclick="DOM_toggleAllMining()" type="button" class="btn btn-dark rounded-0" style="width: 100%">Start All Miners</button>
							
							<!-- Miner Options -->
							<button type="button" class="btn btn-dark rounded-0 dropdown-toggle dropdown-toggle-split" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
								<span class="sr-only">Toggle Dropdown</span>
							</button>
							<div class="dropdown-menu">
								<a id="toggleMinerMiningBtn" class="dropdown-item" onclick="DOM_toggleMining()">Toggle mining for miner</a>
								<a id="clearMinerBlockchainBtn" class="dropdown-item" onclick="DOM_clearMinerBlockchain()">Clear blockchain for miner</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" onclick="if(confirm('You\'re about to clear everyone\'s blockchain data.')) DOM_clearBlockchain()">Clear all blockchains</a>
								<a class="dropdown-item" onclick="DOM_setNetworkDifficulty()">Set network difficulty</a>
								<a class="dropdown-item" onclick="toggleSha256()" id="useSHA256Btn">Use secure SHA-256 (slower)</a>
								<a class="dropdown-item" onclick="DOM_setBlockSizes()">Set block sizes</a>
								<div class="dropdown-divider"></div>
								<a class="dropdown-item" data-toggle="modal" data-target="#viewNetworkModal" onclick="regenerateNetworkJSON()">View full network</a>
							</div>
						</div>
					</div>
				</div>
				<div class="col-md-8">
					<div class="row px-3">
						<div id="jsoneditor"></div>
						<span id="editMinerBadge" class="ml-auto badge badge-secondary"></span>
					</div>
				</div>
			</div>
		</div>
		<div class="row">
			<div class="col-md-12 mb-3">
				<div class="btn-group fillx" style="max-height: 35px; cursor: pointer">

					<!-- Menu -->
					<button type="button" class="btn btn-dark dropdown-toggle dropdown-toggle-split rounded-0" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" onclick="$('#addMinerBadge').text('')" style="width: 100%">
						<span class="sr-only">Toggle Dropdown</span>
						<span id="addMinerBadge" class="badge badge-light"></span>
					</button>
					<div class="dropdown-menu">
						<a class="dropdown-item" id="vis_refresh_btn" onclick="vis_setupNetworkSimulation()">Refresh topology visualizer</a>
						<a class="dropdown-item" id="vis_line_length_btn" onclick="vis_setLineLengths()">Set line lengths</a>
						<div class="dropdown-divider" id="vis_btn_delimeter" ></div>
						<a class="dropdown-item" onclick="toggleVisualizations()">Toggle visualizations</a>
						<a class="dropdown-item" onclick="DOM_toggleMinerStatsTable()">Toggle miner stats table</a>
						<a class="dropdown-item" onclick="DOM_toggleSamplerForm()">Toggle sampler</a>
					</div>
				</div>
			</div>
			<hr>
		</div>
		<div class="row">
			<div class="col-md-12">
				<div id="networkVisualizer"></div>
			</div>
		</div>
		<div class="row">
			<div id="canvasVisualizerContainer" class="col-md-12">
				<div id="canvasVisualizerCodeContainer" class="col-md-12 m-0">
					<label id="canvasVisualizerCodeLabel" for="canvasVisualizerCode">Time Plot:</label>
					<input id="canvasVisualizerCode" type="text" onchange="saveSamplerSettings()"/>
				</div>
				<canvas id="canvasVisualizer" onclick="canvasVisualizerClicked(event)" class="w-100" height="9"></canvas>
			</div>
		</div>
		<div id="minerStatsDiv" class="row">
			<div class="col-md-12">
				<small>
					<table id="minerStatsTable" class="table table-dark table-hover table-responsive mb-0">
					</table>
				</small>
			</div>
		</div>
		<div id="samplerDiv" class="row">
			<div class="col-md-12">
				<div class="card text-white bg-dark rounded-0 px-2">
					<div class="card-header">
						<div class="form-group row">
							<div class="input-group">
							<label for="timePerSample" class="col-sm-3 col-form-label">Time per sample (s)</label>
							<div class="col-sm-9 p-0">
								<input  id="timePerSample" type="number" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" min="0" value="60" required>
							</div>
							</div>
						</div>
						<div class="form-group row">
							<label for="codeBeforeSampling" class="col-sm-3 col-form-label">Run before sampling</label>
							<div class="col-sm-9 p-0">
								<textarea id="codeBeforeSampling" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" rows="1"></textarea>
							</div>
						</div>
						<div class="form-group row">
							<label for="codeBetweenSamples" class="col-sm-3 col-form-label">Run between samples</label>
							<div class="col-sm-9 p-0">
								<textarea id="codeBetweenSamples" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" rows="2"></textarea>
							</div>
						</div>
						<div class="form-group row">
							<label for="codeAfterSampling" class="col-sm-3 col-form-label">Run after sampling</label>
							<div class="col-sm-9 p-0">
								<textarea id="codeAfterSampling" onchange="saveSamplerSettings()" class="form-control text-white bg-dark border border-secondary" rows="1"></textarea>
							</div>
						</div>
						<div class="form-group row">
							<label class="col-sm-3 col-form-label"></label>
							<div class="col-sm-9 p-0">
								<label class="btn btn-secondary">
									<input id="logSamplesCheckbox" type="checkbox" onchange="saveSamplerSettings()"> Log samples to file
								</label>
								<label class="btn btn-secondary">
									<input id="resetBlockchainAfterEachSampleCheckbox" type="checkbox" onchange="saveSamplerSettings()" checked> Reset blockchain after each sample
								</label>
								<label class="btn btn-secondary">
									<input id="updateTableAfterEachSampleCheckbox" type="checkbox" onchange="saveSamplerSettings()" checked> Update table
								</label>
							</div>
						</div>
						<div id="logColumns" class="form-group row">
							<label class="col-sm-3 col-form-label">Log columns (multiselect)</label>
							<div class="col-sm-9 p-0">
								<select id="logColumnsList" multiple="multiple" onchange="saveSamplerSettings()" class="form-control" size="8">
								</select>
							</div>
						</div>
						<div class="form-group row mb-0">
							<button id="toggleSamplingBtn" class="btn btn-primary fillx border border-dark" onclick="toggleSampling()">Begin Sampling</button>
						</div>
					</div>

					<div class="col-md-12 p-2">
						<small>
							<table id="sampleTable" class="table table-dark table-responsive mb-2">
							</table>
						</small>
					</div>
				</div>
			</div>
		</div>

		<!-- Modals -->
		<div class="modal fade" id="addMinerModal" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 class="modal-title">Add or Edit a Miner</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<form>
						<div class="modal-body">
							<div class="form-group row">
								<label for="addMinerName" class="col-sm-4 col-form-label">Name</label>
								<div class="col-sm-8">
									<input type="text" class="form-control" id="addMinerName" value="Bob" onclick="this.select()" onblur="this.value = fixCase(this.value)" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerPower" class="col-sm-4 col-form-label">Computing Power</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerPower" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerLatency" class="col-sm-4 col-form-label">Network Latency (milliseconds)</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerLatency" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerDownloadMBPS" class="col-sm-4 col-form-label">Network Download (mb per second)</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerDownloadMBPS" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="addMinerUploadMBPS" class="col-sm-4 col-form-label">Network Upload (mb per second)</label>
								<div class="col-sm-8">
									<input type="number" class="form-control" id="addMinerUploadMBPS" min="0" value="10" required>
								</div>
							</div>
							<div class="form-group row">
								<label for="multiselectAddPeers" class="col-sm-4 col-form-label">Peers (multiselect)</label>
								<div class="col-sm-8">
									<select id="multiselectAddPeers" multiple="multiple" class="form-control" size="6">
									</select>
								</div>
							</div>
						</div>
						<div class="modal-footer">
							<button id="addMinerSubmit" class="btn btn-default" onclick="DOM_addMiner()" data-dismiss="modal">Add/Edit</button>
						</div>
					</form>
				</div>
			</div>
		</div>
		<div class="modal fade" id="generateTopologyModal" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 class="modal-title">Pick a Topology</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<div class="modal-body">
						<img src="img/topologies.png" style="width: 100%" usemap="#topologies">
						<map id="topologyMap" name="topologies" data-dismiss="modal"  data-toggle="modal" data-target="#generateTopologyModal2">
							<area shape="rect" coords="10, 10, 450, 506" alt="Ring" onclick="DOM_selectTopology('Ring')">
							<area shape="rect" coords="471, 10, 1005, 506" alt="Mesh" onclick="DOM_selectTopology('Mesh')">
							<area shape="rect" coords="1026, 10, 1403, 506" alt="Star" onclick="DOM_selectTopology('Star')">
							<area shape="rect" coords="1424, 10, 1910, 506" alt="Fully Connected" onclick="DOM_selectTopology('Fully Connected')">
							<area shape="rect" coords="10, 527, 740, 931" alt="Line" onclick="DOM_selectTopology('Line')">
							<area shape="rect" coords="761, 527, 1367, 931" alt="Tree" onclick="DOM_selectTopology('Tree')">
							<area shape="rect" coords="1388, 527, 1910, 931" alt="Bus" onclick="DOM_selectTopology('Bus')">
							<area shape="rect" coords="10, 958, 1910, 1412" alt="Line" onclick="DOM_selectTopology('Bitcoin')">
						</map>
					</div>
				</div>
			</div>
		</div>
		<div class="modal fade" id="generateTopologyModal2" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 id="topologyTitle" class="modal-title">Topology</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<form>
						<div class="modal-body">
							<div id="topologyjsoneditor"></div>
						</div>
						<div class="modal-footer">
							<button class="btn btn-default" onclick="DOM_generateTopology()" data-dismiss="modal">Generate</button>
						</div>
					</form>
				</div>
			</div>
		</div>
		<div class="modal fade" id="viewNetworkModal" role="dialog">
			<div class="modal-dialog">
				<!-- Modal content-->
				<div class="modal-content">
					<div class="modal-header">
						<h4 id="topologyTitle" class="modal-title">View Network</h4>
						<button id="closeAddMinerModal" type="button" class="close" data-dismiss="modal">&times;</button>
					</div>
					<div class="modal-body">
						<div id="networkjsoneditor"></div>
						<span id="editNetworkBadge" class="ml-auto badge badge-secondary"></span>
					</div>
				</div>
			</div>
		</div>
	</div>
	<!-- jQuery first, imageMapResizer, then Popper.js, then Bootstrap JS -->
	<script src="lib/jquery-3.2.1.slim.min.js"></script>
	<script src="lib/imageMapResizer.min.js"></script>
	<script src="lib/popper.min.js"></script>
	<script src="lib/bootstrap.min.js"></script>
</body>
<script type="text/javascript">

	let network = null;

	let updateToolOptions = {
		timeout: null,
		selectMinerTimeout: null,
		updateMinerListTimeout: null,
		minerStatsTable_active: true,
		vis_canvas: null,
		vis_network: null,
		vis_simulation_active: true,
		vis_timeout: null,
		vis_nodeIDs: [],
		vis_lineLength: undefined,
		vis_network_blur_timeout: null,
		sampler_DOM_active: true,
		sampler_running: false,
		samplerData: [],
		samplerLog: [],
		sampleStartTime: 0,
		sampleEndTime: 0,
		canvasVisualizerThread: null,
		canvasVisualizerBarWidth: 15,
		canvasVisualizerPixelStepSize: 1,
		canvasVisualizerInterval: 1000 / 30,
		bitcoin_latency_data: { url: null, data: null },
	}


	// Use the 256-bit secure hashing algorithm (SHA256) by calling sha256("data string")
	const sha256 = function a(b) {function c(a,b) {return a>>>b|a<<32-b}for(var d,e,f=Math.pow,g=f(2,32),h="length",i="",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o= {},p=2;64>n;p++)if(!o[p]) {for(d=0;313>d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+="\x80";b[h]%64-56;)b+="\x00";for(d=0;d<b[h];d++) {if(e=b.charCodeAt(d),e>>8)return;j[d>>2]|=e<<(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e<j[h];) {var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64>d;d++) {var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&l[5]^~v&l[6])+m[d]+(q[d]=16>d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s>>>3)+q[d-7]+(c(t,17)^c(t,19)^t>>>10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&l[1]^u&l[2]^l[1]&l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8>d;d++)l[d]=l[d]+r[d]|0}for(d=0;8>d;d++)for(e=3;e+1;e--) {var y=l[d]>>8*e&255;i+=(16>y?0:"")+y.toString(16)}return i};

	// Network class
	class Network {
		constructor() {
			this.name = "";
			
			this.peers = {};
			this.difficulty = 0.01;

			this.blockSize = 1000000;

			this.genesis = new Header();
			this.genesis.height = 0;
			this.genesis.timestamp = Date.now();

			this.useSHA256 = false; // Specify whether or not to actually use genuine hashing (real security, but slow), or to use random numbers and a difficulty threshhold to determine a block (no security, but fast)

			this.ID_Registry = {};
			this.miningThreads = {};
			this.minimumBlockchainPurgeLength = 100;
			this.maximumBlockchainPurgeLength = 200; // When a miner's blockchain reaches this many blocks, it will remove the oldest ones until it's the minimumBlockchainPurgeLength

			// When a block is received, keep track of number of networking data, such as the number of hops
			this.logging = {
				columns: {
					"Sample": true,
					"Sample time": true,
					"Sample tag": false,
					"Miner name": true,
					"Balance": true,
					"Balance %": false,
					"Power (hash/s)": true,
					"Power %": false,
					"Block num hops": true,
					"Block travel time (s)": true,
					"Network buffer size limit": true,
					"Blocks in flight": true,
					"Latency (ms)": true,
					"Download (MBPS)": true,
					"Upload (MBPS)": true,
					"Block height": true,
					"Total blocks found": true,
					"Stale blocks found": true,
					"Max fork length": true,
				},
				logNetworkData: false,
				msPerSample: 20000,
				codeBeforeSampling: "console.log(\"Sampling started at \", Date.now());",
				codeBetweenSamples: "// BOB.power += 10;\nif(numSamples >= 100000) toggleSampling(false);",
				codeAfterSampling: "console.log(\"Sampling ended at \", Date.now());",
				logSamples: false,
				resetBlockchainAfterEachSample: true,
				updateTableAfterEachSample: true,
				canvasVisualizerCode: "miner.lastAcceptedBlock",
			}
		}

		setDifficulty(_difficulty) {
			_difficulty = _difficulty.toString();

			if(_difficulty.startsWith("0x")) {
				_difficulty = _difficulty.substring(2); // Remove the 0x
				let maxDifficulty = parseInt("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF".substring(0, 15), 16);
				let d = parseInt(_difficulty.substring(0, 15), 16) / maxDifficulty;
				if(!isNaN(d)) {
					this.difficulty = d;
				} else {
					alert(`Invalid difficulty value: "${_difficulty}".`);
				}
			} else {
				let d = parseFloat(_difficulty);
				if(!isNaN(d)) {
					this.difficulty = d;
				} else {
					alert(`Invalid difficulty value: "${_difficulty}".`);
				}
			} 
		}

		startAllMiners() {
			for(let id in network.ID_Registry) {
				this.peers[id].startMining();
			}
		}

		stopAllMiners() {
			for(let id in network.ID_Registry) {
				this.peers[id].stopMining();
			}
		}

		removeBlocksInFlight() {
			for(let id in network.ID_Registry) {
				this.peers[id].networkBuffer.clear();
			}
			clearAllTimeouts();
		}

		clearBlockchain() {
			for(let id in this.ID_Registry) {
				this.peers[id].clearBlockchain();
				this.peers[id].networkBuffer.clear();
			}
			clearAllTimeouts();
		}
		findPeerByName(name) {
			for(let id in this.ID_Registry) {
				if(this.peers[id].name == name) return this.peers[id];
			}
			return null;
		}

		// Given a network object, return it in its serialized JSON form
		static serialize(network, compress = true) {
			network.stopAllMiners();
			network.removeBlocksInFlight();
			let json = JSON.stringify(network);
			// Now clone it, remove the temporary properties such as blockchain, then re-convert to JSON
			let newNetwork = JSON.parse(json);
			delete newNetwork.genesis;
			for(let ID in newNetwork.peers) {
				let peer = newNetwork.peers[ID];
				delete peer.lastAcceptedBlock;
				delete peer.blockchain;
				delete peer.blockchainOffset;
				delete peer.currentHeader;
				delete peer.totalBlocksFound;
				delete peer.staleBlocksFound;
				delete peer.largestForkLength;
				delete peer.blockchain_numHops;
				delete peer.blockchain_blockDelay;
				delete peer.networkBuffer;
			}
			let fixedJSON = JSON.stringify(newNetwork, null, "\t");
			if(compress) {
				let compressed = LZString.compressToUTF16('\n' + fixedJSON);
				return compressed;
			}
			return fixedJSON;
		}

		// Given a serialized network, return the network object (consisting of Network, Miner, Header classes)
		static deserialize(json) {
			clearAllTimeouts();
			let decompressed = LZString.decompressFromUTF16(json);
			if(decompressed != null && decompressed.startsWith('\n')) json = decompressed.substring(1);

			try {
				let newNetworkObj = JSON.parse(json);
				let network = new Network();
				// Add logging if it doesn't exist
				if(newNetworkObj.logging === undefined) newNetworkObj.logging = network.logging;
				if(newNetworkObj.logging.columns === undefined) newNetworkObj.logging.columns = network.logging.columns;
				network = Object.assign(network, newNetworkObj);

				for(let peer in network.peers) { // Make all miners Miner objects

					let miner = new Miner(network.peers[peer].name, network.peers[peer].power, network.peers[peer].latency, network.peers[peer].downloadMBPS, network.peers[peer].uploadMBPS);
					miner = Object.assign(miner, network.peers[peer]);
					network.peers[peer] = miner;

					// Make the currentHeader an actual Header object
					let currentHeader = new Header();
					currentHeader = Object.assign(currentHeader, network.peers[peer].currentHeader);
					network.peers[peer].currentHeader = currentHeader;

					// Make the currentHeader an actual Header object
					let lastAcceptedBlock = currentHeader.clone();

					// Make the blocks in the blockchain an actual Header object
					for(let block in network.peers[peer].blockchain) {
						let header = new Header();
						header = Object.assign(header, network.peers[peer].blockchain[block]);
						network.peers[peer].blockchain[block] = header;
					}

					// Recreate the networkBuffer
					let networkBuffer = new NetworkBuffer(miner.ID);
					network.peers[peer].networkBuffer = networkBuffer;
				}
				return network;
			} catch(e) {
				console.error(e);
				alert("Error deserializing the network. See console for more information.");
				return null;
			}
		}
	}

	// Block header class
	class Header {
		constructor() {
			this.solver = null;
			this.height = null;
			this.timestamp = null; // Time block was solved in seconds

			if(network != null) this.numBytes = network.blockSize;
			else this.numBytes = 1000000;

			this.nonce = null;
			this.hash = null;
			this.prevHash = null;
			this.balances = [];
			if(network && network.logging.logNetworkData) {
				this.numHops = 0;
			}
		}

		clone() {
			let newHeader = new Header();
			newHeader.solver = this.solver;
			newHeader.height = this.height;
			newHeader.timestamp = this.timestamp;
			newHeader.hash = this.hash; // Hash doesn't need to be sent, since it can be computed on the receiver's end
			newHeader.prevHash = this.prevHash;
			newHeader.balances = Object.assign({}, this.balances);
			if(network.logging.logNetworkData) {
				newHeader.numHops = this.numHops;
			}
			return newHeader;
		}

		guessNonce() {
			this.nonce = Math.random();
			if(network.useSHA256) {
				// Secure but slower
				const data = this.timestamp.toString() + this.nonce.toString() + this.solver?.toString() + this.height.toString() + this.prevHash?.toString() + this.balances.toString();
				this.hash = sha256(sha256(data));
			} else {
				// Insecure but fast
				this.hash = this.nonce;
			}
		}

		isBlock() {
			if(network.useSHA256) {
				// Secure but slower
				const targetDifficulty = 1152921504606847000; // 0XFFFFFFFFFFFFFFF
				const currentDifficulty = parseInt(this.hash.substring(0, 15), 16);
				return (currentDifficulty / targetDifficulty) <= network.difficulty;
			} else {
				// Insecure but fast
				return this.hash <= network.difficulty;
			}
		}
	}

	class NetworkBuffer {
		constructor(parentID) {
			this.parentID = parentID;
			this.bufferSizeLimit = 1000;
			this.clear();
		}

		// Stop and clear the network buffer
		clear() {
			this.buffer = [];
			clearTimeout(this.thread);
			this.thread = null;
			this.nextInterval = null;
		}

		// If the thread is null, then schedule the next processBuffer function call
		activateBufferProcessor() {
			if(this.thread == null) {
				let packet = this.buffer[0], delay;
				if(packet.to == this.parentID) { // Downloading data
					delay = packet.size / network.peers[this.parentID].downloadMBPS / 1000000 * 1000;
				} else { // Uploading data
					delay = packet.size / network.peers[this.parentID].uploadMBPS / 1000000 * 1000;
				}
				delay += network.peers[this.parentID].latency;
				this.thread = setTimeout(this.processBuffer.bind(this), delay);
				this.nextInterval = delay;
			}
		}

		processBuffer() {
			if(this.buffer.length == 0) {
				clearTimeout(this.thread);
				this.thread = null;
				return;
			}

			// Process the packet
			let packet = this.buffer.shift();
			if(packet.to == this.parentID) { // Downloading data
				let parent = network.peers[this.parentID];
				setTimeout(parent.receive.bind(parent), 0, packet.from, packet.payload);

			} else { // Uploading data
				let networkBufferTo = network.peers[packet.to].networkBuffer;

				if(networkBufferTo.bufferSizeLimit === Infinity || networkBufferTo.buffer.length < networkBufferTo.bufferSizeLimit) {
					networkBufferTo.buffer.push(packet);
					networkBufferTo.activateBufferProcessor();
				} // else their size is too full and the packet must be dropped
			}

			// Schedule the next buffer process
			let delay = 0;
			if(this.buffer.length > 0) {
				let packet = this.buffer[0];
				if(packet.to == this.parentID) { // Downloading data
					delay = packet.size / network.peers[this.parentID].downloadMBPS / 1000000 * 1000;
				} else { // Uploading data
					delay = packet.size / network.peers[this.parentID].uploadMBPS / 1000000 * 1000;
				}
				delay += network.peers[this.parentID].latency;
			}
			this.thread = setTimeout(this.processBuffer.bind(this), delay);
			this.nextInterval = delay;
		}

		send(to_ID, data) {
			let packet = {
				from: this.parentID,
				to: to_ID,
				payload: data,
				size: data.numBytes,
			}
			this.buffer.push(packet);
			this.activateBufferProcessor();
		}
	}

	// Miner class
	class Miner {
		constructor(name, power, latency, downloadMBPS, uploadMBPS) {
			this.name = name;
			// Register a unique ID
			if(network.ID_Registry[this.name] === undefined) {
				this.ID = this.name.toUpperCase().replace(/\s/g, "_"); // Math.random().toString();
			} else { // Guarentee that no peers have the same ID
				let count = 1;
				do {
					this.ID = this.name.toUpperCase().replace(/\s/g, "_") + count;
					count++;
				} while(network.ID_Registry[this.ID] !== undefined);
			}
			network.ID_Registry[this.ID] = null;
			network.peers[this.ID] = this;
			this.power = power;
			this.latency = latency; // Additional latency from the network (milliseconds)
			this.downloadMBPS = downloadMBPS; // Used by the download buffer to receive data
			this.uploadMBPS = uploadMBPS; // Used by the upload buffer to send data
			this.incomingPeers = [];
			this.outgoingPeers = [];

			this.sendInvalidMaliciousBlocks = false; // When enabled, this miner will mine like other miners, however when a "block" is found, it is actually an invalid block, so adjacent nodes will decline it, but it will have already used up part of the neighboring node's bandwidths

			this.lastAcceptedBlock = null;
			this.blockchainOffset = 0; // Due to removing old blocks
			this.blockchain = [network.genesis];
			this.totalBlocksFound = 0;
			this.staleBlocksFound = 0;
			this.largestForkLength = 0;
			this.currentHeader = this.newHeader(network.genesis);
			this.color = "default";
			this.networkBuffer = new NetworkBuffer(this.ID);

			if(network.logging.logNetworkData) {
				this.blockchain_numHops = [];
				this.blockchain_blockDelay = [];
			}
			updateTools();
		}

		destructor() {
			this.stopMining();
			let incomingPeersBackup = this.incomingPeers.slice();
			let outgoingPeersBackup = this.outgoingPeers.slice();

			for(let id of outgoingPeersBackup) {
				this.removeConnection(id);
			}
			for(let id of incomingPeersBackup) {
				if(network.peers[id] !== undefined) {
					network.peers[id].removeConnection(this.ID);
				}
			}
			delete network.ID_Registry[this.ID];
			updateTools();
		}

		getBlock(height) {
			return this.blockchain[height - this.blockchainOffset];
		}

		setBlock(height, block) {
			if(block == undefined) return;
			if(network.logging.logNetworkData && this.blockchain_numHops !== undefined && this.blockchain_blockDelay !== undefined) { // Keep track of networking data
				// If there is a fork, it will always stay up to date by replacing the old stale block data
				this.blockchain_numHops[height] = block.numHops;
				this.blockchain_blockDelay[height] = Date.now() / 1000 - block.timestamp;
			}
			this.blockchain[height - this.blockchainOffset] = block;
			this.lastAcceptedBlock = block.clone();
		}

		// Clear all blockchain data
		clearBlockchain() {
			this.blockchainOffset = 0;
			this.blockchain = [network.genesis];
			this.currentHeader = this.newHeader(network.genesis);
			this.lastAcceptedBlock = this.currentHeader.clone();
			this.totalBlocksFound = 0;
			this.staleBlocksFound = 0;
			this.largestForkLength = 0;
		}

		// Memory optimization with no impact on network, nodes become pruned nodes
		// Check if it is time to remove old blocks, if it is, remove them
		purgeBlockCheck() {
			if(this.blockchain.length >= network.maximumBlockchainPurgeLength) {
				this.blockchainOffset += this.blockchain.length - network.minimumBlockchainPurgeLength;
				this.blockchain = this.blockchain.slice(this.blockchain.length - network.minimumBlockchainPurgeLength);
			}
		}

		startMining() {
			if(network.miningThreads[this.ID] !== undefined) return;
			if(this.power == 0) return;
			network.miningThreads[this.ID] = setInterval(this.mine.bind(this), 1000 / this.power);
			$("#minerList option[value='" + this.ID + "']").html("&#10148; " + this.name);
		}

		stopMining() {
			clearInterval(network.miningThreads[this.ID]);
			delete network.miningThreads[this.ID];
			$("#minerList option[value='" + this.ID + "']").html(this.name);
		}

		mine() {
			this.currentHeader.timestamp = Date.now() / 1000;
			if(this.sendInvalidMaliciousBlocks) {
				while(!this.currentHeader.isBlock()) { // No blocks
					this.currentHeader.guessNonce();
				};
				this.submit(this.currentHeader);
				return;
			}
			this.currentHeader.guessNonce();

			// If it's a malicious node, void the block by guessing another nonce until it is not a block
			

			if(this.currentHeader.isBlock()) {
				//console.log(this.name + " found a block!");

				this.submit(this.currentHeader);
				this.totalBlocksFound++;
				// Set it as the new currentHeader, to mine off of
				this.setBlock(this.currentHeader.height, this.currentHeader);
				this.currentHeader = this.newHeader(this.currentHeader);
				this.purgeBlockCheck();
			}
		}

		addConnection(ID) {
			if(this.ID == ID) return;
			this.outgoingPeers.push(ID);
			network.peers[ID].incomingPeers.push(this.ID);
			updateTools();
		}

		removeConnection(ID) {
			//delete this.outgoingPeers[ID];

			// Go through our connections, remove the ID
			for(let i in this.outgoingPeers) {
				if(this.outgoingPeers[i] == ID) {
					this.outgoingPeers.splice(i, 1);
				}
			}

			// Remove us from that peer's incoming peer list
			if(network.peers[ID] !== undefined) {
				//delete network.peers[ID].incomingPeers[this.ID];
				for(let i in network.peers[ID].incomingPeers) {
					if(network.peers[ID].incomingPeers[i] == this.ID) {
						network.peers[ID].incomingPeers.splice(i, 1);
					}
				}
			}
			updateTools();
		}

		newHeader(prevHeader) { //* Consider sending prevHash instead
			const header = new Header();
			header.solver = this.ID;
			header.height = prevHeader.height + 1;
			header.hash = Number.MAX_SAFE_INTEGER;
			header.prevHash = prevHeader.hash;
			header.balances = Object.assign({}, prevHeader.balances);
			if(header.balances[this.ID] === undefined) {
				header.balances[this.ID] = 1;
			} else {
				header.balances[this.ID]++;
			}
			return header;
		}

		// Broadcast a header to all peers
		submit(header) {
			if(network.logging.logNetworkData) {
				// Keep track of number of hops
				if(header.numHops === undefined) header.numHops = 1;
				else header.numHops++;
			}
			for(let id of this.outgoingPeers) {
				this.networkBuffer.send(id, header.clone());
			}
		}

		// Called when a header is received
		receive(from_ID, newHeader) {
			//console.log("Block " + newHeader.height + ": Received by " + this.ID);

			if(!newHeader.isBlock()) return; // Invalid block message

			if(newHeader.height >= this.blockchain.length + this.blockchainOffset) {
				// If at any point in receiving a block, there is an undefined header, this allows us to undo to the previous working header
				let backupHeaders = [];
				backupHeaders.push(this.getBlock(newHeader.height));
				this.setBlock(newHeader.height, newHeader);
				this.currentHeader = this.newHeader(newHeader);
				let solver = network.peers[newHeader.solver];
				//let newHeader = newHeader; // Go back through the blockchain until we reach the block that both miners share
				let forkLength = 1;
				while(this.getBlock(newHeader.height - 1) === undefined || newHeader.prevHash != this.getBlock(newHeader.height - 1).hash) {
					 // Stale block detector
					if(this.getBlock(newHeader.height - 1) !== undefined && this.ID == this.getBlock(newHeader.height - 1).solver) {
						this.staleBlocksFound++;
						//console.log(this.getBlock(newHeader.height - 1).solver + "'s block became stale");
					}
					let i = newHeader.height;
					newHeader = solver.queryBlockAtHeight(newHeader.height - 1);
					if(newHeader === undefined) {
						while(backupHeaders.length > 0) {
							this.setBlock(i, backupHeaders.pop());
							i++;
						}
						//console.log("Recovered from incomplete transfer");
						return;
					}
					backupHeaders.push(this.getBlock(newHeader.height));
					this.setBlock(newHeader.height, newHeader);
					forkLength++;
				} // Fully synced blockchain!
				if(forkLength > this.largestForkLength) {
					this.largestForkLength = forkLength;
				}
				this.purgeBlockCheck();
				this.submit(this.getBlock(this.blockchain.length + this.blockchainOffset - 1));
			}
		}

		queryBlockAtHeight(height) {
			if(this.getBlock(height) === undefined) return;
			return this.getBlock(height).clone();
		}
	}

	network = new Network();

	// Quickly mine the genesis block
	do {
		network.genesis.guessNonce();
	} while(!network.genesis.isBlock());
	
	const jsoneditorContainer = document.getElementById("jsoneditor");
	const jsoneditor = new JSONEditor(jsoneditorContainer, {
		mode: "tree",
		modes: ["code", "form", "tree"],
		onChangeText: function (jsonString) {
			DOM_editMiner();
		}
	});
	const topologyjsoneditorContainer = document.getElementById("topologyjsoneditor");
	const topologyjsoneditor = new JSONEditor(topologyjsoneditorContainer, {
		mode: "form",
		modes: ["code", "form", "text", "tree", "view"]
	});
	const networkjsoneditorContainer = document.getElementById("networkjsoneditor");
	const networkjsoneditor = new JSONEditor(networkjsoneditorContainer, {
		mode: "view",
		modes: ["code", "form", "text", "tree", "view"],
		onChangeText: function (jsonString) {
			DOM_editNetwork();
		}
	});

	// Clear all currently running timeouts
	function clearAllTimeouts() {
		var id = window.setTimeout(function() {}, 0);
		while (id--) {
			window.clearTimeout(id);
		}
	}

	// bob --> Bob
	function fixCase(str) {
		return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
	}

	// Generate a random integer between a and b
	function rnd(a, b) {
		if(a == b) return a;
		else if(b > a) [a, b] = [b, a];
		return Math.floor(a + Math.random() * (b - a + 1));
	}

	// Randomize array in-place using Durstenfeld shuffle algorithm
	function shuffleArray(array) {
		for (var i = array.length - 1; i > 0; i--) {
			var j = Math.floor(Math.random() * (i + 1));
			var temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
	}

	// Open and return the contents of a file url
	async function openAndReadFile(url) {
		try {
			const response = await fetch(url);
			if(!response.ok) return null;
			return await response.text();
		} catch(e) {
			console.error("Failed to load url \"" + url + "\".", e.message);
			return null;
		}
	}

	// Convert a CSV-formatted string into a JavaScript array
	function CSVToArray(strData, strDelimiter = ","){
        strDelimiter = (strDelimiter || ",");
        var objPattern = new RegExp(
            (
                // Delimiters.
                "(\\" + strDelimiter + "|\\r?\\n|\\r|^)" +

                // Quoted fields.
                "(?:\"([^\"]*(?:\"\"[^\"]*)*)\"|" +

                // Standard fields.
                "([^\"\\" + strDelimiter + "\\r\\n]*))"
            ),
            "gi"
            );
        var arrData = [[]];
        var arrMatches = null;
        while (arrMatches = objPattern.exec(strData)){
            var strMatchedDelimiter = arrMatches[1];
            if (
                strMatchedDelimiter.length &&
                strMatchedDelimiter !== strDelimiter
                ){
                arrData.push([]);
            }
            var strMatchedValue;
            if (arrMatches[2]){
                strMatchedValue = arrMatches[2].replace(
                    new RegExp("\"\"", "g"),
                    "\""
                    );
            } else {
                strMatchedValue = arrMatches[3];
            }
            matchedValue = Number(strMatchedValue);
            if(!isNaN(matchedValue)) {
        	    arrData[arrData.length - 1].push(matchedValue);
            } else {
        	    arrData[arrData.length - 1].push(strMatchedValue);
        	}
        }
        return arrData;
    }


	// Extracts all strings/quotes from a block of code, replacing them by temporary characters, and returns the resulting string along with the array of quotes
	// " --> \u04DC, ' --> \u04DD, ` --> \u04DE
	function extractQuotes(code) {
		code = code.replace(/\u04DC|\u04DD|\u04DE/g, ""); // Prevent intervention
		let outputCode = "", extractedQuotes = [];
		let split = code.split("\"");
		for(let i in split) {
			if(i % 2 == 0) {
				outputCode += split[i];
			} else {
				outputCode += "\u04DC"
				extractedQuotes.push(split[i]);
			}
		}
		split = outputCode.split("'");
		outputCode = ""
		for(let i in split) {
			if(i % 2 == 0) {
				outputCode += split[i];
			} else {
				outputCode += "\u04DD"
				extractedQuotes.push(split[i]);
			}
		}
		split = outputCode.split("`");
		outputCode = ""
		for(let i in split) {
			if(i % 2 == 0) {
				outputCode += split[i];
			} else {
				outputCode += "\u04DE"
				extractedQuotes.push(split[i]);
			}
		}
		return [outputCode, extractedQuotes];
	}

	// Take the output from the extractQuotes function, and return the full code with the strings/quotes inserted
	function reinsertQuotes(array) {
		while(array[0].includes("\u04DC")) {
			array[0] = array[0].replace("\u04DC", "\"" + array[1].shift() + "\"");
		}
		while(array[0].includes("\u04DD")) {
			array[0] = array[0].replace("\u04DD", "'" + array[1].shift() + "'");
		}
		while(array[0].includes("\u04DE")) {
			array[0] = array[0].replace("\u04DE", "`" + array[1].shift() + "`");
		}
		return array[0];
	}

	// Create a new miner
	function newMiner(name0, power, latency, downloadMBPS, uploadMBPS, createNewIfExists = true) {
		let name = name0;
		if(createNewIfExists) {
			// Create a new name/miner by appending a counter to the end, so that the name is unique
			let count = 2;
			while(network.findPeerByName(name) != null) {
				name = name0 + count.toString();
				count++;
			}
		}

		for(let id in network.ID_Registry) {
			if(network.peers[id].name == name) return;
		}
		const miner = new Miner(name, power, latency, downloadMBPS, uploadMBPS);
		//$("#minerList").append("<option value=\"" + miner.ID + "\">" + miner.name + "</option>");
		updateMinerList();
		selectMiner(miner.ID); // Select it
		return miner;
	}

	// Connect every peer to every other peer
	function fullyConnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 in network.ID_Registry) {
				network.peers[id1].addConnection(id2);
			}
		}
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Make all peer connections bidirectional
	function bidirectionallyConnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 of network.peers[id1].outgoingPeers) {
				network.peers[id2].addConnection(id1);
			}
		}
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Disonnect every peer to every other peer
	function fullyDisconnectPeers() {
		for(let id1 in network.ID_Registry) {
			for(let id2 in network.ID_Registry) {
				network.peers[id1].removeConnection(id2);
			}
		}
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Remove everyone's copy of the blockchain
	function DOM_clearBlockchain() {
		network.stopAllMiners();
		network.removeBlocksInFlight();
		network.clearBlockchain();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
		DOM_selectedMiner();
	}

	// Clear the selected miner's blockchain
	function DOM_clearMinerBlockchain() {
		const e = $("#minerList option:selected");
		const miner = network.peers[e.val()];
		if(miner === undefined) {
			$("#addMinerBadge").attr("class", "badge badge-warning");
			$("#addMinerBadge").text("NO MINER SELECTED");
		} else {
			miner.clearBlockchain();
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("SUCCESS");
		}
	}

	$(document).ready(function() {

		// First try loading the filename "", if it doesn't exist, then generate a random topology
		if(loadLocalStorageQuiet("") == false) {
			generateTopology({
				"Type": "Mesh",
				"Bidirectional": true,
				"Prevent duplicate connections": true,
				"Number of peers": 10,
				"Minimum number of connections": 1,
				"Maximum number of connections": 1,
				"Minimum power": 10,
				"Maximum power": 10,
				"Minimum download megabytes per second": 1,
				"Maximum download megabytes per second": 50,
				"Minimum upload megabytes per second": 1,
				"Maximum upload megabytes per second": 50,
				"Minimum latency": 10,
				"Maximum latency": 10,
			  "Naming cycle": ["Alice", "Andrew", "Bob", "Chris", "George", "James", "Jack", "Eve", "Frank", "Carl"]
			  //let minerNames = ["Aaron", "Adam", "Alan", "Albert", "Alex", "Alice", "Andrew", "Anthony", "Arthur", "Austin", "Ben", "Bill", "Bob", "Bobby", "Brandon", "Brian", "Bruce", "Carl", "Charles", "Chris", "Dan", "Daniel", "David", "Dennis", "Donald", "Douglas", "Dylan", "Edward", "Eric", "Ethan", "Eugene", "Frank", "Gabriel", "Gary", "George", "Gerald", "Gregory", "Harold", "Harry", "Henry", "Jack", "Jacob", "James", "Jason", "Jeffrey", "Jeremy", "Jerry", "Jesse", "Joe", "John", "Johnny", "Jonathan", "Jordan", "Jose", "Joseph", "Joshua", "Juan", "Justin", "Keith", "Kenneth", "Kevin", "Kyle", "Larry", "Lawrence", "Logan", "Louis", "Mark", "Matthew", "Michael", "Nathan", "Nicholas", "Noah", "Patrick", "Paul", "Peter", "Philip", "Ralph", "Randy", "Raymond", "Richard", "Robert", "Roger", "Ronald", "Roy", "Russell", "Ryan", "Samuel", "Scott", "Sean", "Stephen", "Steven", "Terry", "Thomas", "Timothy", "Tyler", "Vincent", "Walter", "Wayne", "Will", "Zachary"];
			});
			loadSamplerSettings();
			saveSamplerSettings();
		}
		$("#minerList option:first").prop("selected", true);
		$("#minerList option:first").change();
		$("#addMinerBadge").text("");
		updateToolOptions.minerStatsTable_active = !updateToolOptions.minerStatsTable_active;
		DOM_toggleMinerStatsTable();
		updateToolOptions.vis_simulation_active = !updateToolOptions.vis_simulation_active;
		toggleVisualizations();
	});

	function saveLocalStorage() {
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith("NETWORK_FILE_")) {
				files.push(key.substring(13));
			}
		}
		let fileName = prompt("Saving a file as an empty string will load it every time the page is refreshed.\n\nFiles:\n[\"" + files.join("\", \"") + "\"]\n\nEnter a file name to create/replace:", network.name);
		if(fileName == null) return;

		network.name = fileName;
		fileName = "NETWORK_FILE_" + fileName;

		let json = Network.serialize(network);
		localStorage.setItem(fileName, json);
	}

	function loadLocalStorage() {
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith("NETWORK_FILE_")) {
				files.push(key.substring(13));
			}
		}
		let prefill = network.name;
		if(prefill == '' && files.length == 1) prefill = files[0];
		let fileName = prompt("Files:\n[\"" + files.join("\", \"") + "\"]\n\nPlease enter a file name to load:", prefill);
		if(fileName == null) return;
		fileName = "NETWORK_FILE_" + fileName;

		let json = localStorage.getItem(fileName);
		if(json == null) {
			alert("File could not be found.")
		} else {
			temp_network = Network.deserialize(json);
			if(temp_network == null) return;
			network = temp_network;

			numPeers = Object.keys(network.peers).length;
			if(numPeers >= 50 && updateToolOptions.vis_simulation_active) {
				let disableNetworkVisualizer  = confirm(`You are loading ${numPeers} nodes. Would you like to disable the network visualizer for an increase in performance?`);
				if(disableNetworkVisualizer) {
					toggleVisualizations();
				}
			}

			updateTools();
			updateMinerList();
			loadSamplerSettings();
			if(Object.keys(network.peers).length > 0) selectMiner(Object.keys(network.peers)[0]);
			DOM_toggleLoggingNetworkData(network.logging.logNetworkData);
		}
	}

	function loadLocalStorageQuiet(fileName) {
		fileName = "NETWORK_FILE_" + fileName;

		let json = localStorage.getItem(fileName);
		if(json == null) {
			return false;
		} else {
			temp_network = Network.deserialize(json);
			if(temp_network == null) return;
			network = temp_network;

			numPeers = Object.keys(network.peers).length;
			if(numPeers >= 50 && updateToolOptions.vis_simulation_active) {
				toggleVisualizations();
			}

			updateTools();
			updateMinerList();
			loadSamplerSettings();
			DOM_toggleLoggingNetworkData(network.logging.logNetworkData);
		}
		return true;
	}

	function deleteLocalStorage() {
		let files = [];
		for (var key in localStorage) {
			if(key.startsWith("NETWORK_FILE_")) {
				files.push(key.substring(13));
			}
		}
		let fileName = prompt("Files:\n[" + files.join(", ") + "]\n\nPlease enter a file name to delete:");
		if(fileName == null) return;
		fileName = "NETWORK_FILE_" + fileName;

		localStorage.removeItem(fileName);
	}

	function clearAllLocalStorage() {
		if(confirm("Are you sure you would like to clear all the saved networks from your browser?")) {
			localStorage.clear();
			alert("LocalStorage has been cleared.")
		}
	}

	function saveToFile(compress = true) {
		let data = Network.serialize(network, compress);
		var a = document.createElement("a");
		if (compress) {
			// ref: https://stackoverflow.com/q/6226189
			var charCode, byteArray = [];
			byteArray.push(254, 255); // BE BOM
			// byteArray.push(255, 254); // LE BOM
			for (var i = 0; i < data.length; ++i) {
				charCode = data.charCodeAt(i);
				byteArray.push((charCode & 0xFF00) >>> 8); // BE Bytes
				byteArray.push(charCode & 0xFF);
				// byteArray.push(charCode & 0xff); // LE Bytes
				// byteArray.push(charCode / 256 >>> 0);
			}
			var blob = new Blob([new Uint8Array(byteArray)], {
				type: 'text/plain;charset=UTF-16BE;'
			});
			var blobUrl = URL.createObjectURL(blob);
			a.setAttribute("href", blobUrl);
			a.setAttribute("download", "simulator_network_" + network.name.replace(/\s/g, '_') + ".dat");
		} else {
			a.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(data));
			a.setAttribute("download", "simulator_network_" + network.name.replace(/\s/g, '_') + ".json");
		}
		a.click();
	}

	function loadFromFile() {
		file = new Promise((resolve) => {
			const input = document.createElement("input");
			input.type = "file";
			input.accept = ".json, .dat"
			input.addEventListener("change", () => {
				resolve(input.files[0]);
			});
			input.click();
		}).then(file => {
			//var file = e.dataTransfer.files[0],
			read = new FileReader();
			read.readAsText(file, "text/plain;charset=UTF-16BE;");
			read.onloadend = function(){
				let json = read.result;

				temp_network = Network.deserialize(json);
				if(temp_network == null) return;
				network = temp_network;

				numPeers = Object.keys(network.peers).length;
				if(numPeers >= 50 && updateToolOptions.vis_simulation_active) {
					let disableNetworkVisualizer  = confirm(`You are loading ${numPeers} nodes. Would you like to disable the network visualizer for an increase in performance?`);
					if(disableNetworkVisualizer) {
						toggleVisualizations();
					}
				}

				updateTools();
				updateMinerList();
				loadSamplerSettings();
				if(Object.keys(network.peers).length > 0) selectMiner(Object.keys(network.peers)[0]);
				DOM_toggleLoggingNetworkData(network.logging.logNetworkData);
			}
		});

		/**/
	}

	// Called when a node is created or deleted
	function updateTools() {
		if(updateToolOptions.timeout != null) return;
		updateToolOptions.timeout = setTimeout(_updateTools, 300);
	}

	// Cannot be called more than once every 300ms
	function _updateTools() {
		if(updateToolOptions.minerStatsTable_active) {
			updateMinerStatsTable();
		}
		if(updateToolOptions.vis_simulation_active) {
			vis_setupNetworkSimulation();
		}
		updateToolOptions.timeout = null;
	}

	// Update the list of miners
	function updateMinerList() {
		clearTimeout(updateToolOptions.updateMinerListTimeout);
		updateToolOptions.updateMinerListTimeout = setTimeout(_updateMinerList, 300);
	}

	// Update the list of miners
	function _updateMinerList() {
		$("#minerList").empty();
		for(let peer in network.peers) {
			$("#minerList").append("<option value=\"" + peer + "\">" + network.peers[peer].name + "</option>");
		}
		if(updateToolOptions.selectedMiner == null) updateToolOptions.selectedMiner = Object.keys(network.peers)[0];
		selectMiner(updateToolOptions.selectedMiner);
	}

	function addMinerBtnClicked() {
		$("#multiselectAddPeers").empty();
		for(let id in network.ID_Registry) {
			$("#multiselectAddPeers").append("<option value=\'" + id + "\'>" + network.peers[id].name + "</option>")
		}
		const selectionID = $("#minerList option:selected").val();
		if(selectionID !== undefined) {
			const miner = network.peers[selectionID];
			$("#addMinerName").val(miner.name);
			$("#addMinerPower").val(miner.power);
			$("#addMinerLatency").val(miner.latency);
			$("#addMinerDownloadMBPS").val(miner.downloadMBPS);
			$("#addMinerUploadMBPS").val(miner.uploadMBPS);
			for(let id of miner.outgoingPeers) {
				$("#multiselectAddPeers option[value=" + id + "]").prop("selected", true);
			}
			
		}
	}

	function DOM_selectedMiner() {
		const miner = network.peers[$("#minerList").val()];
		updateMinerJsonEditor(miner);
		if(miner === undefined) return;

		$("#removeMinerBtn").text("Remove " + miner.name);
		$("#toggleMinerMiningBtn").text("Toggle mining for " + miner.name);
		$("#clearMinerBlockchainBtn").text("Clear blockchain for  " + miner.name);
		
		$("#editMinerBadge").text("");
		if(updateToolOptions.vis_simulation_active) try {
			updateToolOptions.vis_network.selectNodes([updateToolOptions.vis_nodeIDs[miner.ID]]);
		} catch(e) {}
	}

	// Update the data in the json editor, if id is not provided, just use the selected one from the table
	function updateMinerJsonEditor(id) {
		if(id === undefined) id = network.peers[$("#minerList").val()];

		if(id === undefined) jsoneditor.set({});
		else jsoneditor.set(id);
	}

	// Prevent computational overhead of repeated selectMiner calls
	function selectMiner(id) {
		if(id == null) return;
		clearTimeout(updateToolOptions.selectMinerTimeout);
		updateToolOptions.selectMinerTimeout = setTimeout(_selectMiner, 100, id);
		updateToolOptions.selectedMiner = id;
	}

	// Select a miner from the mining list
	function _selectMiner(id) {
		$("#minerList option:selected").prop("selected", false);
		if(id === undefined) return;
		$("#minerList option[value='" + id + "']").prop("selected", true);
		$("#minerList option:selected").change();
		//focusOnNode(nodeId, [options])
	}

	$("#addMinerModal").on("shown.bs.modal", function (e) {
		$("#addMinerBadge").text("");
	});

	$("#generateTopologyModal").on("shown.bs.modal", function (e) {
		$("map").imageMapResize();
	});

	function DOM_globalSetPower() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the computing power of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "10, 100");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseInt(input.trim());
			num2 = num1;
		} else {
			num1 = parseInt(input.substring(0, i).trim());
			num2 = parseInt(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].power = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_globalSetLatency() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the network latency (in milliseconds) of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "10, 100");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseFloat(input.trim());
			num2 = num1;
		} else {
			num1 = parseFloat(input.substring(0, i).trim());
			num2 = parseFloat(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].latency = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_globalSetDownloadMBPS() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the network download megabytes per second of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "0.5, 10");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseFloat(input.trim());
			num2 = num1;
		} else {
			num1 = parseFloat(input.substring(0, i).trim());
			num2 = parseFloat(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].downloadMBPS = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_globalSetUploadMBPS() {
		$("#addMinerBadge").text("");
		const input = prompt("You are about to set the network upload megabytes per second of every miner in the network randomly between a range of numbers.\n\nEnter one value, or two values separated by a comma.", "0.5, 10");
		if(input == null) return; // Cancel button pressed
		let i = input.indexOf(","), num1, num2;
		if(i == -1) {
			num1 = parseFloat(input.trim());
			num2 = num1;
		} else {
			num1 = parseFloat(input.substring(0, i).trim());
			num2 = parseFloat(input.substring(i+1, input.length).trim());
		}
		for(let id in network.ID_Registry) {
			network.peers[id].uploadMBPS = Math.max(0, rnd(num1, num2))
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	function DOM_addMiner() {
		$("#addMinerName").val(fixCase($("#addMinerName").val()));
		const name = fixCase($("#addMinerName").val());
		const power = parseFloat($("#addMinerPower").val());
		const latency = parseFloat($("#addMinerLatency").val());
		const downloadMBPS = parseFloat($("#addMinerDownloadMBPS").val());
		const uploadMBPS = parseFloat($("#addMinerUploadMBPS").val());
		const peers = $("#multiselectAddPeers").val();
		let miner = newMiner(name, power, latency, downloadMBPS, uploadMBPS, false);
		if(miner === undefined) {
			// The same name exists, check if any options have changed, otherwise edit the miner
			miner = network.findPeerByName(name);
			if(miner.power == power && miner.latency == latency && miner.downloadMBPS == downloadMBPS && miner.uploadMBPS == uploadMBPS) {
				let noChanges = true;
				for(let id of peers) {
					if(miner.ID == id) continue;
					if(miner.outgoingPeers[id] === undefined) {
						noChanges = false;
						break;
					}
				}
				for(let id of miner.outgoingPeers) {
					if(miner.ID == id) continue;
					if(!peers.includes(id)) {
						noChanges = false;
						break;
					}
				}
				if(noChanges) {
					$("#addMinerBadge").attr("class", "badge badge-primary");
					$("#addMinerBadge").text("NO CHANGES WERE MADE");
					return;
				}
			}
			miner.power = power;
			miner.latency = latency;
			miner.downloadMBPS = downloadMBPS;
			miner.uploadMBPS = uploadMBPS;
			for(let id of miner.outgoingPeers) {
				miner.removeConnection(id);
			}
			for(let id of peers) {
				if(!miner.outgoingPeers.includes(id)) {
					miner.addConnection(id);
				}
			}
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("EDITED " + miner.name.toUpperCase());
		} else {
			for(let id of peers) {
				if(!miner.outgoingPeers.includes(id)) {
					miner.addConnection(id);
				}
			}
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("ADDED " + miner.name.toUpperCase());
		}
	}

	function DOM_removeMiner() {
		const e = $("#minerList option:selected");
		const miner = network.peers[e.val()];
		const name = miner.name;
		if(miner === undefined) {
			$("#addMinerBadge").attr("class", "badge badge-warning");
			$("#addMinerBadge").text("NO MINER SELECTED");
		} else {
			miner.destructor();
			delete network.peers[e.val()];
			e.remove();
			$("#removeMinerBtn").text("Remove miner");
			$("#toggleMinerMiningBtn").text("Toggle mining for miner");
			$("#addMinerBadge").attr("class", "badge badge-success");
			$("#addMinerBadge").text("REMOVED " + name.toUpperCase());
		}
	}

	function DOM_removeAllMiners() {
		for(let id in network.ID_Registry) {
			network.peers[id].destructor();
		}
		network.peers = {};
		network.ID_Registry = {};
		$("#minerList").empty();
		$("#removeMinerBtn").text("Remove miner");
		$("#toggleMinerMiningBtn").text("Toggle mining for miner");
	}

	function DOM_sortMiners() {
		const options = $("#minerList option");
		options.sort(function(a, b) {
			if (a.text.toUpperCase() > b.text.toUpperCase()) return 1;
			else if (a.text.toUpperCase() < b.text.toUpperCase()) return -1;
			else return 0;
		});
		$("#minerList").empty().append(options);
	}

	// Duplicates the current network to create two instances of it
	function duplicateTopology() {
		if(!confirm("You are about to duplicate your topology, the number of peers will double.\n\nContinue?")) return;
		let minerNames = ["Aaron", "Adam", "Alan", "Albert", "Alex", "Alice", "Andrew", "Anthony", "Arthur", "Austin", "Ben", "Bill", "Bob", "Bobby", "Brandon", "Brian", "Bruce", "Carl", "Charles", "Chris", "Dan", "Daniel", "David", "Dennis", "Donald", "Douglas", "Dylan", "Edward", "Eric", "Ethan", "Eugene", "Frank", "Gabriel", "Gary", "George", "Gerald", "Gregory", "Harold", "Harry", "Henry", "Jack", "Jacob", "James", "Jason", "Jeffrey", "Jeremy", "Jerry", "Jesse", "Joe", "John", "Johnny", "Jonathan", "Jordan", "Jose", "Joseph", "Joshua", "Juan", "Justin", "Keith", "Kenneth", "Kevin", "Kyle", "Larry", "Lawrence", "Logan", "Louis", "Mark", "Matthew", "Michael", "Nathan", "Nicholas", "Noah", "Patrick", "Paul", "Peter", "Philip", "Ralph", "Randy", "Raymond", "Richard", "Robert", "Roger", "Ronald", "Roy", "Russell", "Ryan", "Samuel", "Scott", "Sean", "Stephen", "Steven", "Terry", "Thomas", "Timothy", "Tyler", "Vincent", "Walter", "Wayne", "Will", "Zachary"];
		shuffleArray(minerNames);
		try {
			if(network.peers[Object.keys(network.ID_Registry)[0]].name.length == 1) {
				minerNames = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
			}
		} catch(e) {}

		let translation = {};

		for(let peerID in network.peers) {
			let peer = network.peers[peerID];
			let newName = minerNames[0];
			for(let name of minerNames) {
				if(network.findPeerByName(name) == null) {
					newName = name;
					break;
				}
			}
			let miner = newMiner(newName, peer.power, peer.latency, peer.downloadMBPS, peer.uploadMBPS, true);
			translation[peer.ID] = miner.ID;
		}
		for(let peerID in translation) {
			let peer = network.peers[peerID];
			let newPeer = network.peers[translation[peerID]];
			for(let outgoingPeer of peer.outgoingPeers) {
				outgoingPeersTranslation = translation[outgoingPeer];

				if(outgoingPeersTranslation === undefined) continue;
				newPeer.addConnection(outgoingPeersTranslation);
			}
		}
	}

	function regenerateTopology() {
		/*let translation = {};

		for(let peerID in network.peers) {
			let peer = network.peers[peerID];
			let newName = minerNames[0];
			for(let name of minerNames) {
				if(network.findPeerByName(name) == null) {
					newName = name;
					break;
				}
			}
			let miner = newMiner(newName, peer.power, peer.latency, peer.downloadMBPS, peer.uploadMBPS, true);
			translation[peer.ID] = miner.ID;
		}
		for(let peerID in translation) {
			let peer = network.peers[peerID];
			let newPeer = network.peers[translation[peerID]];
			for(let outgoingPeer of peer.outgoingPeers) {
				outgoingPeersTranslation = translation[outgoingPeer];

				if(outgoingPeersTranslation === undefined) continue;
				newPeer.addConnection(outgoingPeersTranslation);
			}
		}*/
	}

	function DOM_toggleLoggingNetworkData(override) {
		if(override !== undefined) network.logging.logNetworkData = !override;
		if(network.logging.logNetworkData) {
			network.logging.logNetworkData = false;
			$("#DOM_item_toggleLoggingNetworkData").html("Enable logging network<br>data within each miner");
			if(network) for(peerID in network.peers) { // Clean up
				delete network.peers[peerID]["blockchain_numHops"];
				delete network.peers[peerID]["blockchain_blockDelay"];
			}
		} else {
			$("#DOM_item_toggleLoggingNetworkData").html("Disable logging network<br>data within each miner");
			if(network) for(peerID in network.peers) { // Initialization
				network.peers[peerID]["blockchain_numHops"] = [];
				network.peers[peerID]["blockchain_blockDelay"] = []
			}
			network.logging.logNetworkData = true;
		}
		updateMinerJsonEditor();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");
	}

	// Refresh the full network data viewer
	function regenerateNetworkJSON() {
		networkjsoneditor.set(network);
		//alert(JSON.stringify(network))
	}

	function DOM_editMiner() {
		network.stopAllMiners();
		const miner = jsoneditor.get();
		if(miner === undefined) {
			$("#editMinerBadge").attr("class", "ml-auto badge badge-danger");
			$("#editMinerBadge").text("NO DATA");
		} else if(miner.ID === undefined) {
			$("#editMinerBadge").attr("class", "ml-auto badge badge-danger");
			$("#editMinerBadge").text("MINER NOT FOUND");
		} else if(network.peers[miner.ID] === undefined) {
			$("#editMinerBadge").attr("class", "ml-auto badge badge-warning");
			$("#editMinerBadge").text("ID NOT FOUND");
		} else if(typeof miner.power != "number" || typeof miner.latency != "number" || typeof miner.downloadMBPS != "number" || typeof miner.uploadMBPS != "number") {
			// Type checking
			$("#editMinerBadge").attr("class", "ml-auto badge badge-danger");
			$("#editMinerBadge").text("MUST BE A NUMBER");
		} else {
			// Merge the changes into the peer, excluding the current header
			miner.currentHeader = network.peers[miner.ID].currentHeader;
			miner.lastAcceptedBlock = network.peers[miner.ID].lastAcceptedBlock;
			miner.networkBuffer = network.peers[miner.ID].networkBuffer;
			Object.assign(network.peers[miner.ID], miner);
			$("#minerList  option[value='" + miner.ID + "']").text(miner.name);
			$("#editMinerBadge").attr("class", "ml-auto badge badge-primary");
			$("#editMinerBadge").text("SUCCESSFULLY SAVED");
		}
	}

	// TODO: Enable editing the network directly
	function DOM_editNetwork() {
		/*const newNetwork = networkjsoneditor.get();
		if(newNetwork === undefined) {
			$("#editNetworkBadge").attr("class", "ml-auto badge badge-danger");
			$("#editNetworkBadge").text("ERROR");
		} else {
			// Merge the changes into the peer, excluding the current header
			Object.assign(network, newNetwork);
			$("#editNetworkBadge").attr("class", "ml-auto badge badge-primary");
			$("#editNetworkBadge").text("SUCCESSFULLY SAVED");
		}*/
		$("#editNetworkBadge").attr("class", "ml-auto badge badge-warning");
		$("#editNetworkBadge").text("NOT SAVED");
	}

	function DOM_selectTopology(topology) {
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("");
		$("#topologyTitle").text(topology + " Topology");
		let options = {};
		switch(topology) {
			case "Ring":
				options = {
					"Type": topology,
					"Bidirectional": false,
					"Number of peers": 6,
					"Minimum power": 5,
					"Maximum power": 10,
					"Minimum download megabytes per second": 1,
					"Maximum download megabytes per second": 50,
					"Minimum upload megabytes per second": 1,
					"Maximum upload megabytes per second": 50,
					"Minimum latency": 10,
					"Maximum latency": 10,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Mesh":
				options = {
					"Type": "Mesh",
					"Bidirectional": true,
					"Prevent duplicate connections": true,
					"Number of peers": 10,
					"Minimum number of connections": 1,
					"Maximum number of connections": 1,
					"Minimum power": 5,
					"Maximum power": 10,
					"Minimum download megabytes per second": 1,
					"Maximum download megabytes per second": 50,
					"Minimum upload megabytes per second": 1,
					"Maximum upload megabytes per second": 50,
					"Minimum latency": 10,
					"Maximum latency": 10,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				  	//"Naming cycle": ["Alice", "Andrew", "Bob", "George", "Jack", "Eve", "Frank", "Carl"]
				};
				break;
			case "Star":
				options = {
					"Type": topology,
					"Bidirectional": true,
					"Towards center (if bidirectional=false)": true,
					"Number of peers": 6,
					"Minimum power": 5,
					"Maximum power": 10,
					"Minimum download megabytes per second": 1,
					"Maximum download megabytes per second": 50,
					"Minimum upload megabytes per second": 1,
					"Maximum upload megabytes per second": 50,
					"Minimum latency": 10,
					"Maximum latency": 10,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Fully Connected":
				options = {
					"Type": topology,
					"Number of peers": 4,
					"Minimum power": 5,
					"Maximum power": 10,
					"Minimum download megabytes per second": 1,
					"Maximum download megabytes per second": 50,
					"Minimum upload megabytes per second": 1,
					"Maximum upload megabytes per second": 50,
					"Minimum latency": 10,
					"Maximum latency": 10,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Line":
				options = {
					"Type": topology,
					"Bidirectional": true,
					"Number of peers": 6,
					"Minimum power": 5,
					"Maximum power": 10,
					"Minimum download megabytes per second": 1,
					"Maximum download megabytes per second": 50,
					"Minimum upload megabytes per second": 1,
					"Maximum upload megabytes per second": 50,
					"Minimum latency": 10,
					"Maximum latency": 10,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Tree":
				options = {
					"Type": topology,
					"Bidirectional": true,
					"Structure": [[[],[],[]],[[],[],[]],[[],[],[]]],
					"Minimum power": 5,
					"Maximum power": 10,
					"Minimum download megabytes per second": 1,
					"Maximum download megabytes per second": 50,
					"Minimum upload megabytes per second": 1,
					"Maximum upload megabytes per second": 50,
					"Minimum latency": 10,
					"Maximum latency": 10,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			case "Bus":
				options = {
					"Type": topology,
					"Number of peers": 6,
					"Minimum power": 5,
					"Maximum power": 10,
					"Minimum download megabytes per second": 1,
					"Maximum download megabytes per second": 50,
					"Minimum upload megabytes per second": 1,
					"Maximum upload megabytes per second": 50,
					"Minimum latency": 10,
					"Maximum latency": 10,
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;

			case "Bitcoin":
				options = {
					"Type": topology,
					"Number of peers": 100,
					"Number of peer connections": 25,
					"Minimum power": 1,
					"Maximum power": 1,
					// https://www.statista.com/statistics/896779/average-mobile-fixed-broadband-download-upload-speeds
					"Minimum download megabytes per second": 84.33,
					"Maximum download megabytes per second": 84.33,
					"Minimum upload megabytes per second": 44.1,
					"Maximum upload megabytes per second": 44.1,
					// Recorded average latency of every public node in Bitcoin as of 04/01/2021
					"Latency distribution URL": "data/bitcoin_latencies/bitcoin_latencies.csv",
					"Naming cycle": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]
				};
				break;
			default:
				return;
		}
		topologyjsoneditor.set(options);

	}

	function DOM_generateTopology() {
		try {
			// Do an extra check to disable the network visualizer if it may be too computationally taxing
			let json = topologyjsoneditor.get();
			if(json["Number of peers"] !== undefined && json["Type"] != "Bitcoin") { // The Bitcoin topology automatically disables the visualizer
				numPeers = parseInt(json["Number of peers"]) || 0;
				if(numPeers >= 50 && updateToolOptions.vis_simulation_active) {
					let disableNetworkVisualizer  = confirm(`You are generating ${numPeers} nodes. Would you like to disable the network visualizer for an increase in performance?`);
					if(disableNetworkVisualizer) {
						toggleVisualizations();
					}
				}
			}

			generateTopology(json);
			$("#minerList option:first").prop("selected", true);
			$("#minerList option:first").change();
			updateTools();
		} catch(e) {
			alert(e);
			return;
		}
	}

	function generateTopology(options) {
		console.log("Function called:\n\ngenerateTopology(" + JSON.stringify(options) + ")")
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("");
		DOM_removeAllMiners();
		let promise = null;
		let miners, chosenNames, bidirectional, nPeers, minPower, maxPower, minLatency, maxLatency, names, minNumConnections, maxNumConnections, structure;
		switch(options["Type"]) {
			case "Ring":
				bidirectional = !!options["Bidirectional"];
				nPeers = options["Number of peers"] ?? 6;
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				minLatency = options["Minimum latency"] ?? 10;
				maxLatency = options["Maximum latency"] ?? 100;
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					if(bidirectional) miners[i + 1].addConnection(miners[i].ID);
				}
				miners[miners.length - 1].addConnection(miners[0].ID);
				if(bidirectional) miners[0].addConnection(miners[miners.length - 1].ID);
				break;

			case "Mesh":
				minNumConnections = options["Minimum number of connections"] ?? 1;
				maxNumConnections = options["Maximum number of connections"] ?? 1;
				bidirectional = !!options["Bidirectional"];
				preventDuplicateConnections = !!options["Prevent duplicate connections"];
				nPeers = options["Number of peers"] ?? 6;
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				minLatency = options["Minimum latency"] ?? 10;
				maxLatency = options["Maximum latency"] ?? 100;
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length; i++) {
					let nConnections = rnd(minNumConnections, maxNumConnections);
					for(let j = 0; j < nConnections; j++) {
						let r = rnd(0, miners.length - 1);
						// Attempt to connect to a unique connections at most 10 times
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
						if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);


						if(preventDuplicateConnections && (miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID))) continue;

						miners[i].addConnection(miners[r].ID);
						if(bidirectional) miners[r].addConnection(miners[i].ID);
					}
				}
				break;

			case "Star":
				towardsCenter = !!options["Towards center (if bidirectional=false)"];
				bidirectional = !!options["Bidirectional"];
				nPeers = options["Number of peers"] ?? 6;
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				minLatency = options["Minimum latency"] ?? 10;
				maxLatency = options["Maximum latency"] ?? 100;
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				if(bidirectional) {
					for(let i = 1; i < miners.length; i++) {
						miners[i].addConnection(miners[0].ID);
						miners[0].addConnection(miners[i].ID);
					}
				} else if(towardsCenter) {
					for(let i = 1; i < miners.length; i++) {
						miners[i].addConnection(miners[0].ID);
					}
				} else {
					for(let i = 1; i < miners.length; i++) {
						miners[0].addConnection(miners[i].ID);
					}
				}
				break;

			case "Fully Connected":
				nPeers = options["Number of peers"] ?? 4;
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				minLatency = options["Minimum latency"] ?? 10;
				maxLatency = options["Maximum latency"] ?? 100;
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length; i++) {
					for(let j = 0; j < miners.length; j++) {
						miners[i].addConnection(miners[j].ID);
						miners[j].addConnection(miners[i].ID);
					}
				}
				break;

			case "Line":
				bidirectional = !!options["Bidirectional"];
				nPeers = options["Number of peers"] ?? 6;
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				minLatency = options["Minimum latency"] ?? 10;
				maxLatency = options["Maximum latency"] ?? 100;
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					if(bidirectional) miners[i + 1].addConnection(miners[i].ID);
				}
				break;

			case "Tree":
				bidirectional = !!options["Bidirectional"];
				structure = options["Structure"];
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				minLatency = options["Minimum latency"] ?? 10;
				maxLatency = options["Maximum latency"] ?? 100;
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				chosenNames = [];
				let i = 0;
				recursivelyGenerateTreeTopology(structure, null);
				function recursivelyGenerateTreeTopology(structure, parent) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					let miner = newMiner(name, power, latency, downloadMBPS, uploadMBPS, true);
					if(parent != null) {
						if(bidirectional) {
							miner.addConnection(parent.ID);
							parent.addConnection(miner.ID);
						} else {
							miner.addConnection(parent.ID);
						}
					}
					for(let child of structure) {
						i++;
						recursivelyGenerateTreeTopology(child, miner, i);
					}
				}
				break;

			case "Bus":
				nPeers = options["Number of peers"] ?? 6;
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				minLatency = options["Minimum latency"] ?? 10;
				maxLatency = options["Maximum latency"] ?? 100;
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
				miners = [];
				chosenNames = [];
				for(let i = 0; i < nPeers; i++) {
					let name = names[i % names.length];
					if(chosenNames[name] !== undefined) {
						let count = 1;
						do {
							name = names[i % names.length] + count.toString();
							count++;
						} while(chosenNames[name] !== undefined);
					}
					chosenNames[name] = true;
					let power = rnd(minPower, maxPower);
					let latency = rnd(minLatency, maxLatency);
					let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
					let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
					miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
				}
				for(let i = 0; i < miners.length - 1; i++) {
					miners[i].addConnection(miners[i + 1].ID);
					miners[i + 1].addConnection(miners[i].ID);
				}
				break;

			case "Bitcoin":

				nPeers = options["Number of peers"] ?? 100;
				numConnections = options["Number of peer connections"] ?? 25;
				bidirectional = true;
				preventDuplicateConnections = true;
				minPower = options["Minimum power"] ?? 10;
				maxPower = options["Maximum power"] ?? 10;
				minDownloadMBPS = options["Minimum download megabytes per second"] ?? 10;
				maxDownloadMBPS = options["Maximum download megabytes per second"] ?? 10;
				minUploadMBPS = options["Minimum upload megabytes per second"] ?? 10;
				maxUploadMBPS = options["Maximum upload megabytes per second"] ?? 10;
				latencyUrl = options["Latency distribution URL"] ?? "data/bitcoin_latencies/bitcoin_latencies.csv";
				names = options["Naming cycle"] ?? ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];

				if(updateToolOptions.vis_simulation_active) {
					console.info("Disabling the topology visualizer for improved performance. This can be re-enabled by clicking the dropdown above the table and selecting \"Toggle topology visualizer\".");
					toggleVisualizations();
				}

				const gen = () => {
					miners = [];
					chosenNames = [];
					for(let i = 0; i < nPeers; i++) {
						let name = names[i % names.length];
						if(chosenNames[name] !== undefined) {
							let count = 1;
							do {
								name = names[i % names.length] + count.toString();
								count++;
							} while(chosenNames[name] !== undefined);
						}
						chosenNames[name] = true;
						let power = rnd(minPower, maxPower);
						// Pick a random latency from the real-world Bitcoin distribution data
						let latency = updateToolOptions.bitcoin_latency_data.data[Math.floor(Math.random() * updateToolOptions.bitcoin_latency_data.data.length)][1]; // Second column in the CSV file

						let downloadMBPS = rnd(minDownloadMBPS, maxDownloadMBPS);
						let uploadMBPS = rnd(minUploadMBPS, maxUploadMBPS);
						miners.push(newMiner(name, power, latency, downloadMBPS, uploadMBPS, true));
					}
					for(let i = 0; i < miners.length; i++) {
						// m=n-1 if n<25 and m=24 if n>=25 --> The number of connections per node
						let nConnections = miners.length < numConnections ? miners.length - 1 : numConnections;

						for(let j = 0; j < nConnections; j++) {
							let r = rnd(0, miners.length - 1);
							// Attempt to connect to a unique connections at most 10 times
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);
							if(miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID)) r = rnd(0, miners.length - 1);


							if(preventDuplicateConnections && (miners[i].ID == miners[r].ID || miners[i].outgoingPeers.includes(miners[r].ID))) continue;

							miners[i].addConnection(miners[r].ID);
							if(bidirectional) miners[r].addConnection(miners[i].ID);
						}
					}
				}

				// Dynamically fetch the URL files, and cache them in updateToolOptions for later use
				if(latencyUrl != updateToolOptions.bitcoin_latency_data.url) {
					promise = openAndReadFile(latencyUrl).then(latencies => {
						let latencyArray = CSVToArray(latencies);
						if(latencyArray.length < 2) {
							console.warn("Unable to find the URL CSV latency data. Using global average latency as backup.");
							updateToolOptions.bitcoin_latency_data.url = latencyUrl;							updateToolOptions.bitcoin_latency_data.data = [["Global average", 409.91]]; // Average hardcoded latency of the network
						} else {
							// Remove the CSV headers
							latencyArray.shift();
							updateToolOptions.bitcoin_latency_data.url = latencyUrl;
							updateToolOptions.bitcoin_latency_data.data = latencyArray;
						}
						gen();
					});
				} else gen();
				break;

			default:
				$("#addMinerBadge").attr("class", "badge badge-danger");
				$("#addMinerBadge").text("UNEXPECTED TOPOLOGY");
		}
		DOM_selectedMiner();
		$("#addMinerBadge").attr("class", "badge badge-success");
		$("#addMinerBadge").text("SUCCESS");

		if(promise == null) {
			// Create a blank promise that resolves instantly
			promise = Promise.resolve();
		}
		return promise;
	}

	// Check if an object is a promise
	function isPromise(promise) {  
		return !!promise && typeof promise.then === 'function'
	}

	function DOM_setNetworkDifficulty() {
		const difficulty = prompt("Enter a network difficulty threshhold in hex, or in decimal (as the probability of finding a block).\n\nEasiest difficulty = 1.0 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF", network.difficulty);
		if(difficulty == null) return;
		network.setDifficulty(difficulty);
		alert("Difficulty has been set to " + network.difficulty * 100 + "% chance of a nonce being a block.");
	}

	function toggleSha256() {
		if(network.useSHA256) {
			network.useSHA256 = false;
			$("#useSHA256Btn").text("Use secure SHA-256 (slower)");
			alert("Using real security (SHA-256) has been disabled.");
		} else {
			network.useSHA256 = true;
			$("#useSHA256Btn").text("Use fast block verification");
			alert("Using real security (SHA-256) has been enabled.");
		}
	}

	function DOM_setBlockSizes() {
		try {
			const blockSize = prompt("Enter a block size in bytes", network.blockSize);
			let size = parseInt(blockSize);
			if(size > 0) {
				network.blockSize = size;
				alert("The block size has been updated to " + size + " bytes.");
			}
		} catch(e) {}
	}

	function DOM_toggleMining() {
		const e = $("#minerList option:selected");
		const miner = network.peers[e.val()];
		if(miner === undefined) {
			$("#addMinerBadge").attr("class", "badge badge-warning");
			$("#addMinerBadge").text("NO MINER SELECTED");
		} else {
			if(network.miningThreads[miner.ID] !== undefined) {
				miner.stopMining();
			} else {
				miner.startMining();
				$("#toggleMiningBtn").text("Stop All Miners");
				if(updateToolOptions.vis_simulation_active) startCanvasVisualizerThread();
			}
		}
	}

	function DOM_toggleAllMining() {
		if($("#toggleMiningBtn").text() == "Start All Miners") {
			$("#toggleMiningBtn").text("Stop All Miners");
			network.startAllMiners();
			if(updateToolOptions.vis_simulation_active) startCanvasVisualizerThread();
			$("#toggleMiningBtn").attr("class", "btn btn-warning rounded-0 border border-top-0 border-dark");
		} else {
			$("#toggleMiningBtn").text("Start All Miners");
			network.stopAllMiners();
			stopCanvasVisualizerThread();
			$("#toggleMiningBtn").attr("class", "btn btn-dark rounded-0");
		}
	}

	function DOM_toggleMinerStatsTable() {
		let minerStatsDiv = document.getElementById("minerStatsDiv");
		if(updateToolOptions.minerStatsTable_active) {
			updateToolOptions.minerStatsTable_active = false;
			$("#minerStatsTable").html("");
			$("#minerStatsDiv").hide();
		} else {
			updateToolOptions.minerStatsTable_active = true;
			updateMinerStatsTable();
			$("#minerStatsDiv").show();
		}
	}

	function updateMinerStatsTable() {
		if(!updateToolOptions.minerStatsTable_active) return;

		let html = "<thead>";
		html += "<th scope='col'><button onclick='updateMinerStatsTable()' class='btn btn-secondary'>Refresh</button></th>";
		html += "<th scope='col'>Account balance</th>";
		html += "<th scope='col' class='text-warning'>%</th>";
		html += "<th scope='col'>Power (H/s)</th>";
		html += "<th scope='col' class='text-warning'>%</th>";

		if(network.logging.logNetworkData) {
			html += "<th scope='col'>Block num hops</th>";
			html += "<th scope='col'>Block travel time</th>";
		}
		html += "<th scope='col'>Blocks in flight</th>";

		html += "<th scope='col'>Latency (ms)</th>";
		html += "<th scope='col'>Download rate (mbps)</th>";
		html += "<th scope='col'>Upload rate (mbps)</th>";
		html += "<th scope='col'>In peers</th>";
		html += "<th scope='col'>Out peers</th>";
		html += "<th scope='col'>Block height</th>";
		html += "<th scope='col'>Total blocks found</th>";
		html += "<th scope='col'>Stale blocks found</th>";
		html += "<th scope='col'>Max fork length</th>";
		html += "</thead>";
		html += "<tbody>";
		let sum = {
			power: 0,
			numHops: 0,
			blockDelay: 0,
			blocksInFlight: 0,
			latency: 0,
			downloadMBPS: 0,
			uploadMBPS: 0,
			balance: 0,
			incomingPeers: 0,
			outgoingPeers: 0,
			height: 0,
			totalBlocksFound: 0,
			staleBlocksFound: 0,
			largestForkLength: 0,
		}
		let avg = {
			power: 0,
			numHops: 0,
			blockDelay: 0,
			blocksInFlight: 0,
			latency: 0,
			downloadMBPS: 0,
			uploadMBPS: 0,
			balance: 0,
			incomingPeers: 0,
			outgoingPeers: 0,
			height: 0,
			totalBlocksFound: 0,
			staleBlocksFound: 0,
			largestForkLength: 0,
		}
		let numPeers = 0;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			sum.power += miner.power;

			if(network.logging.logNetworkData) { // Keep track of networking data
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;
					sum.numHops += numHopsAvg;
					sum.blockDelay += blockDelayAvg;
				} catch(e) {}
			}

			sum.blocksInFlight += miner.networkBuffer.buffer.length;
			sum.latency += miner.latency;
			sum.downloadMBPS += miner.downloadMBPS;
			sum.uploadMBPS += miner.uploadMBPS;
			sum.balance += (miner.currentHeader.balances[id] - 1);
			sum.incomingPeers += miner.incomingPeers.length;
			sum.outgoingPeers += miner.outgoingPeers.length;
			sum.height += (miner.currentHeader.height - 1);
			sum.totalBlocksFound += miner.totalBlocksFound;
			sum.staleBlocksFound += miner.staleBlocksFound;
			sum.largestForkLength += miner.largestForkLength;
			numPeers++;
		}
		avg.power = Math.floor(sum.power / numPeers * 1000) / 1000;
		if(network.logging.logNetworkData) { // Keep track of networking data
			avg.numHops = Math.floor(sum.numHops / numPeers * 1000) / 1000;
			avg.blockDelay = Math.floor(sum.blockDelay / numPeers * 1000) / 1000;
		}
		avg.blocksInFlight = Math.floor(sum.blocksInFlight / numPeers * 1000) / 1000;
		avg.latency = Math.floor(sum.latency / numPeers * 1000) / 1000;
		avg.downloadMBPS = Math.floor(sum.downloadMBPS / numPeers * 1000) / 1000;
		avg.uploadMBPS = Math.floor(sum.uploadMBPS / numPeers * 1000) / 1000;
		avg.balance = Math.floor(sum.balance / numPeers * 1000) / 1000;
		avg.incomingPeers = Math.floor(sum.incomingPeers / numPeers * 1000) / 1000;
		avg.outgoingPeers = Math.floor(sum.outgoingPeers / numPeers * 1000) / 1000;
		avg.height = Math.floor(sum.height / numPeers * 1000) / 1000;
		avg.totalBlocksFound = Math.floor(sum.totalBlocksFound / numPeers * 1000) / 1000;
		avg.staleBlocksFound = Math.floor(sum.staleBlocksFound / numPeers * 1000) / 1000;
		avg.largestForkLength = Math.floor(sum.largestForkLength / numPeers * 1000) / 1000;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			html += "<tr onclick='selectMiner(\"" + miner.ID + "\")'>";
			html += "<th scope='col'>" + miner.name + "</th>";
			html += "<th scope='col'>" + (miner.currentHeader.balances[id] - 1) + " BTC</th>";
			html += "<th scope='col' class='text-warning'>" + (Math.floor((miner.currentHeader.balances[id] - 1) / sum.balance * 100000) / 1000 || 0) + "</th>";
			html += "<th scope='col'>" + miner.power + "</th>";
			html += "<th scope='col' class='text-warning'>" + (Math.floor(miner.power / sum.power * 100000) / 1000) + "</th>";

			if(network.logging.logNetworkData) { // Keep track of networking data
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;

					html += "<th scope='col'>" + (Math.floor(numHopsAvg * 1000) / 1000) + "</th>";
					html += "<th scope='col'>" + (Math.floor(blockDelayAvg * 1000) / 1000) + "</th>";
				} catch(e) {
					html += "<th scope='col'></th>";
					html += "<th scope='col'></th>";
				}
			}

			html += "<th scope='col'>" + miner.networkBuffer.buffer.length + "</th>";
			html += "<th scope='col'>" + miner.latency + "</th>";
			html += "<th scope='col'>" + miner.downloadMBPS + "</th>";
			html += "<th scope='col'>" + miner.uploadMBPS + "</th>";

			html += "<th scope='col'>" + miner.incomingPeers.length + "</th>";
			html += "<th scope='col'>" + miner.outgoingPeers.length + "</th>";
			html += "<th scope='col'>" + (miner.currentHeader.height - 1) + "</th>";
			html += "<th scope='col'>" + miner.totalBlocksFound + "</th>";
			html += "<th scope='col'>" + miner.staleBlocksFound + "</th>";
			html += "<th scope='col'>" + miner.largestForkLength + "</th>";
			html += "</tr>";
		}
		html += "<tr class='text-dark bg-light'>";
		html += "<th scope='col'>Sum<br>Average</th>";
		html += "<th scope='col'>" + sum.balance + "<br>" + avg.balance + "</th>";
		html += "<th scope='col'></th>";
		html += "<th scope='col'>" + sum.power + "<br>" + avg.power + "</th>";
		html += "<th scope='col'></th>";

		if(network.logging.logNetworkData) { // Keep track of networking data
			html += "<th scope='col'>" + (Math.floor(sum.numHops * 1000) / 1000) + "<br>" + (Math.floor(avg.numHops * 1000) / 1000) + "</th>";
			html += "<th scope='col'>" + (Math.floor(sum.blockDelay * 1000) / 1000) + "<br>" + (Math.floor(avg.blockDelay * 1000) / 1000) + "</th>";
		}

		html += "<th scope='col'>" + sum.blocksInFlight + "<br>" + avg.blocksInFlight + "</th>";
		html += "<th scope='col'>" + sum.latency + "<br>" + avg.latency + "</th>";
		html += "<th scope='col'>" + sum.downloadMBPS + "<br>" + avg.downloadMBPS + "</th>";
		html += "<th scope='col'>" + sum.uploadMBPS + "<br>" + avg.uploadMBPS + "</th>";
		html += "<th scope='col'>" + sum.incomingPeers + "<br>" + avg.incomingPeers + "</th>";
		html += "<th scope='col'>" + sum.outgoingPeers + "<br>" + avg.outgoingPeers + "</th>";
		html += "<th scope='col'>" + sum.height + "<br>" + avg.height + "</th>";
		html += "<th scope='col'>" + sum.totalBlocksFound + "<br>" + avg.totalBlocksFound + "</th>";
		html += "<th scope='col'>" + sum.staleBlocksFound + "<br>" + avg.staleBlocksFound + "</th>";
		html += "<th scope='col'>" + sum.largestForkLength + "<br>" + avg.largestForkLength + "</th>";
		html += "</tr>";

		html += "</tbody>";
		$("#minerStatsTable").html(html);
	}

	function toggleVisualizations() {
		let vis_container = document.getElementById("networkVisualizer");
		if(updateToolOptions.vis_simulation_active) {
			updateToolOptions.vis_simulation_active = false;
			vis_clearNetworkSimulation();
			$("#vis_refresh_btn").hide();
			$("#vis_line_length_btn").hide();
			$("#vis_btn_delimeter").hide();

			$("#canvasVisualizerContainer").hide();
			stopCanvasVisualizerThread();
			clearCanvasVisualizer();
		} else {
			updateToolOptions.vis_simulation_active = true;
			updateToolOptions.vis_timeout = null;
			vis_container.style.height = "500px";
			vis_container.style.opacity = "1";
			vis_setupNetworkSimulation();
			$("#vis_refresh_btn").show();
			$("#vis_line_length_btn").show();
			$("#vis_btn_delimeter").show();

			$("#canvasVisualizerContainer").show();
		}
	}

	function setupCanvasVisualizer() {
		const canvas = document.getElementById("canvasVisualizer");
		const ctx = canvas.getContext("2d");
		canvas.width = $("#canvasVisualizer").width();
		canvas.height = Object.keys(network.peers).length * updateToolOptions.canvasVisualizerBarWidth;

		let numPeers = Object.keys(network.peers).length;
		let barsize = Math.ceil(canvas.height / numPeers);
		let i = 0;
		for(let id in network.peers) {
			let color = network.peers[id].color;
			let y = Math.floor(i * canvas.height / numPeers);
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(canvas.width - barsize / 1.5, y + barsize / 2, barsize / 2 - 1, 0, 2 * Math.PI);
			ctx.fill();
			//ctx.fillRect(canvas.width - barsize, y, barsize, barsize);
			i++;
		}


		if($("#toggleMiningBtn").text().startsWith("Stop")) {
			startCanvasVisualizerThread();
		}
	}

	function canvasVisualizerClicked(event) {
		let canvas = document.getElementById("canvasVisualizer");
		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		let minerIDs = Object.keys(network.peers);
		let numPeers = minerIDs.length;
		let barsize = Math.ceil(canvas.height / numPeers);
		let minerIndex = Math.floor(y / barsize);
		if(minerIndex < 0 || minerIndex >= numPeers) return;
		let miner = minerIDs[minerIndex];
		selectMiner(miner);
	}

	// java String#hashCode
	function hashCode(str) {
		var hash = 0;
		for (var i = 0; i < str.length; i++) {
			hash = str.charCodeAt(i) + ((hash << 5) - hash);
		}
		return hash;
	} 

	function intToRGB(i){
		var c = (i & 0x00FFFFFF).toString(16).toUpperCase();
		return "00000".substring(0, 6 - c.length) + c;
	}

	function startCanvasVisualizerThread() {
		if(updateToolOptions.canvasVisualizerThread == null) {
			updateToolOptions.canvasVisualizerThread = setInterval(updateCanvasVisualizer, updateToolOptions.canvasVisualizerInterval);
		}
	}

	function stopCanvasVisualizerThread() {
		clearInterval(updateToolOptions.canvasVisualizerThread);
		updateToolOptions.canvasVisualizerThread = null;
	}

	function clearCanvasVisualizer() {
		const canvas = document.getElementById("canvasVisualizer");
		const ctx = canvas.getContext("2d");
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}

	function updateCanvasVisualizer() {
		if(updateToolOptions.vis_simulation_active == false) {
			clearInterval(updateToolOptions.canvasVisualizerThread);
			updateToolOptions.canvasVisualizerThread = null;
			return;
		}

		let numPeers = Object.keys(network.peers).length;

		const code = network.logging.canvasVisualizerCode;
		const canvas = document.getElementById("canvasVisualizer");
		const ctx = canvas.getContext("2d");
		let barsize = Math.ceil(canvas.height / numPeers);
		let px = updateToolOptions.canvasVisualizerPixelStepSize ?? 1;

		imageData = ctx.getImageData(px, 0, canvas.width - px - Math.floor(barsize * 1.5), canvas.height);
		ctx.putImageData(imageData, 0, 0);
		ctx.clearRect(canvas.width - px - Math.floor(barsize * 1.5), 0, px, canvas.height);

		let i = 0;
		for(let id in network.peers) {
			let obj = "", str = "";
			try {
				let miner = network.peers[id];
				obj = eval(network.logging.canvasVisualizerCode) ?? "";
				str = JSON.stringify(obj);
			} catch(e) {}

			let color = intToRGB(hashCode(str));

			ctx.fillStyle = "#" + color;
			let y = Math.floor(i * canvas.height / numPeers);
			ctx.fillRect(canvas.width - px - Math.floor(barsize * 1.5), y, px, barsize);
			i++;
		}
	}

	function vis_clearNetworkSimulation() {
		let vis_container = document.getElementById("networkVisualizer");
		updateToolOptions.vis_nodeIDs = []
		updateToolOptions.vis_network = new vis.Network(vis_container, {}, {});
		vis_container.innerHTML = "";
		vis_container.style.height = "0";
		vis_container.style.opacity = "0";
	}

	function vis_setLineLengths() {
		let length_s = prompt("How long should lines be?")
		if(length_s == null) return;
		let length = parseInt(length_s) || undefined;

		updateToolOptions.vis_lineLength = length;
		vis_setupNetworkSimulation();
	}

	function vis_setupNetworkSimulation() {
		// Wait a minimum time before allowing the next simulation setup
		if(updateToolOptions.vis_timeout != null) return;
		updateToolOptions.vis_timeout = setTimeout(_vis_setupNetworkSimulation, 510);
	}

	function _vis_setupNetworkSimulation() {
		updateToolOptions.vis_nodeIDs = []
		let vis_nodes = [], vis_edges = [], i = 0;
		for(let id in network.ID_Registry) {
			updateToolOptions.vis_nodeIDs[id] = i;
			vis_nodes.push({
				id: updateToolOptions.vis_nodeIDs[id],
				label: network.peers[id].name,
				group: i,
				color: network.peers[id].color == "default" ? undefined : network.peers[id].color,
			});
			i++;
		}

		for(let id1 in network.ID_Registry) {
			for(let id2 of network.peers[id1].outgoingPeers) {
				vis_edges.push({
					from: updateToolOptions.vis_nodeIDs[id1],
					to: updateToolOptions.vis_nodeIDs[id2],
					length: updateToolOptions.vis_lineLength,
					// Add dashes to lines that are not bi-directional connections
					// dashes: network.peers[id2].outgoingPeers.includes(id1) ? false : [10, 10],
				});
			}
		}
		let vis_container = document.getElementById("networkVisualizer");

		updateToolOptions.vis_network_options = {
			nodes: {
				shape: "dot",
				size: 30,
				font: {
					size: 32,
					color: "#FFF"
				},
				borderWidth: 4,
			},
			edges: {
				width: 6
			},
			layout: {
				improvedLayout: true
			},
			interaction:{
				dragView: false,
				selectConnectedEdges: false,
				zoomView: false,
				dragNodes: false
			},
		};

		updateToolOptions.vis_network = new vis.Network(vis_container, {
			nodes: vis_nodes,
			edges: vis_edges
		}, updateToolOptions.vis_network_options);

		// Retrieve the node color from the vis.js datastructure
		let vis_rawNodeData = updateToolOptions.vis_network.nodesHandler.body.nodes;
		let style = "";
		for(let id in updateToolOptions.vis_nodeIDs) {
			try {
				let vis_rawNode = vis_rawNodeData[updateToolOptions.vis_nodeIDs[id]];
				let color = vis_rawNode.options.color.background;
				network.peers[id].color = color;
				style += "#minerList option:checked[value=\"" + id + "\"]{border-right:20px solid " + color + ";padding-left:10px}";
			} catch(e) {}
		}
		document.getElementById("miner-colors-selector").innerHTML = style;

		updateMinerJsonEditor();

		updateToolOptions.vis_network.on("selectNode", function (params) {
			let miner, minerID;
			for(let id in updateToolOptions.vis_nodeIDs) {
				if(updateToolOptions.vis_nodeIDs[id] == params.nodes[0]) {
					minerID = id;
				}
			}
			selectMiner(minerID);
		});

		updateToolOptions.vis_network.view.canvas.frame.addEventListener("focus", function() {
			let option = {
				interaction: {
					zoomView: true,
					dragNodes: true
				}
			};
			updateToolOptions.vis_network.setOptions(option);
		});
		updateToolOptions.vis_network.view.canvas.frame.addEventListener("blur", function() {
			let option = {
				interaction: {
					zoomView: false,
					dragNodes: false
				}
			};
			updateToolOptions.vis_network.setOptions(option);
		});
		
		updateToolOptions.vis_network.on("zoom", function (e) {
			pos = updateToolOptions.vis_network.getViewPosition();
			if(updateToolOptions.vis_network.getScale() <= 0.11) {
				updateToolOptions.vis_network.moveTo({
					position: { x: 0, y: 0},
					scale: 0.11,
				});
			} else {
				updateToolOptions.vis_network.moveTo({
					position: { x: 0, y: 0},
				});
			}
		});
		updateToolOptions.vis_timeout = null;

		setupCanvasVisualizer();
	}

	// Save the code from the DOM to the network data
	function saveSamplerSettings() {

		network.logging.msPerSample = Math.floor(Number($("#timePerSample").val()) * 1000);

		// Add the code wrapper
		let _code = "let numSamples = updateToolOptions.numSamples, samplerData = updateToolOptions.samplerData;\nfunction setTag(tag) {\n\tupdateToolOptions.sampleTag = tag.toString();\n}\n\n";

		network.logging.codeBeforeSampling = "{\n" + _code + $("#codeBeforeSampling").val() + "\n}";
		network.logging.codeBetweenSamples = "{\n" + _code + $("#codeBetweenSamples").val() + "\n}";
		network.logging.codeAfterSampling = "{\n" + _code + $("#codeAfterSampling").val() + "\n}";

		network.logging.logSamples = $("#logSamplesCheckbox").prop("checked");
		network.logging.resetBlockchainAfterEachSample = $("#resetBlockchainAfterEachSampleCheckbox").prop("checked");
		network.logging.updateTableAfterEachSample = $("#updateTableAfterEachSampleCheckbox").prop("checked");

		// Update the list of log columns
		let columns = $("#logColumnsList").val();
		for(let column in network.logging.columns) {
			network.logging.columns[column] = false;
		}
		for(let column of columns) {
			network.logging.columns[column] = true;
		}

		if(network.logging.logSamples) $("#logColumns").show();
		else $("#logColumns").hide();

		network.logging.canvasVisualizerCode = "{" + $("#canvasVisualizerCode").val() + "}";
	}

	// Load the code from the network to the DOM
	function loadSamplerSettings() {
		$("#timePerSample").val(network.logging.msPerSample / 1000);

		// Remove the code wrapper
		let _code = "let numSamples = updateToolOptions.numSamples, samplerData = updateToolOptions.samplerData;\nfunction setTag(tag) {\n\tupdateToolOptions.sampleTag = tag.toString();\n}\n\n";

		let codeBeforeSampling = network.logging.codeBeforeSampling;
		let codeBetweenSamples = network.logging.codeBetweenSamples;
		let codeAfterSampling = network.logging.codeAfterSampling;

		if(codeBeforeSampling.startsWith("{\n")) codeBeforeSampling = codeBeforeSampling.substring(2);
		if(codeBetweenSamples.startsWith("{\n")) codeBetweenSamples = codeBetweenSamples.substring(2);
		if(codeAfterSampling.startsWith("{\n")) codeAfterSampling = codeAfterSampling.substring(2);

		if(codeBeforeSampling.startsWith(_code)) codeBeforeSampling = codeBeforeSampling.substring(_code.length);
		if(codeBetweenSamples.startsWith(_code)) codeBetweenSamples = codeBetweenSamples.substring(_code.length);
		if(codeAfterSampling.startsWith(_code)) codeAfterSampling = codeAfterSampling.substring(_code.length);

		if(codeBeforeSampling.endsWith("\n}")) codeBeforeSampling = codeBeforeSampling.slice(0, -2);
		if(codeBetweenSamples.endsWith("\n}")) codeBetweenSamples = codeBetweenSamples.slice(0, -2);
		if(codeAfterSampling.endsWith("\n}")) codeAfterSampling = codeAfterSampling.slice(0, -2);

		$("#codeBeforeSampling").val(codeBeforeSampling);
		$("#codeBetweenSamples").val(codeBetweenSamples);
		$("#codeAfterSampling").val(codeAfterSampling);

		$("#logSamplesCheckbox").prop("checked", network.logging.logSamples);
		$("#resetBlockchainAfterEachSampleCheckbox").prop("checked", network.logging.resetBlockchainAfterEachSample);
		$("#updateTableAfterEachSampleCheckbox").prop("checked", network.logging.updateTableAfterEachSample);

		$("#logColumnsList").empty();
		for(let column in network.logging.columns) {
			$("#logColumnsList").append("<option value=\"" + column + "\">" + column + "</option>");
			$("#logColumnsList option[value=\"" + column + "\"]").prop("selected", network.logging.columns[column]);
		}
		if(network.logging.logSamples) $("#logColumns").show();
		else $("#logColumns").hide();

		// Canvas visualizer code
		let canvasVisualizerCode = network.logging.canvasVisualizerCode;
		if(canvasVisualizerCode.startsWith("{")) canvasVisualizerCode = canvasVisualizerCode.substring(1);
		if(canvasVisualizerCode.endsWith("}")) canvasVisualizerCode = canvasVisualizerCode.slice(0, -1);
		$("#canvasVisualizerCode").val(canvasVisualizerCode);
	}

	function DOM_toggleSamplerForm() {
		if(updateToolOptions.sampler_DOM_active) {
			$("#samplerDiv").hide();
			updateToolOptions.sampler_DOM_active = false;
		} else {
			$("#samplerDiv").show();
			updateToolOptions.sampler_DOM_active = true;
		}
	}

	function toggleSampling(override) {
		if(override !== undefined) updateToolOptions.sampler_running = !override;
		if(updateToolOptions.sampler_running) {
			stopSampling();
			$("#toggleSamplingBtn").text("Begin Sampling");
			$("#toggleSamplingBtn").attr("class", "btn btn-primary fillx border border-dark");
			updateToolOptions.sampler_running = false;
			updateSamplerTable();
		} else {
			initSampler();
			$("#toggleSamplingBtn").text("Stop Sampling");
			$("#toggleSamplingBtn").attr("class", "btn btn-warning fillx border border-dark");
			updateToolOptions.sampler_running = true;
			network.startAllMiners();
			updateToolOptions.sampleStartTime = new Date().getTime();
			setTimeout(sample, network.logging.msPerSample);
		}
	}

	function registerSamplerForId(id) {
		updateToolOptions.samplerData[id] = {
			sumBalance: 0,
			sumPower: 0,
			sumNumHops: 0,
			sumBlockDelay: 0,
			sumBlocksInFlight: 0,
			sumLatency: 0,
			sumDownloadMBPS: 0,
			sumUploadMBPS: 0,
			sumBlockHeight: 0,
			sumTotalBlocks: 0,
			sumStaleBlocks: 0,
			sumMaxForkLength: 0,
		}
	}

	// Given a code with miner IDs referenced by the user, convert it into executable JavaScript by inserting the network.peers[] wrapper around code not surrounded by quotes
	function getDynamicSampleCode(code) {
		let temp = extractQuotes(code);
		// Convert miner IDs into proper references
		for(let id in network.ID_Registry) {
			const r = new RegExp("([^A-z0-9_])" + id + "([^A-z0-9_])", "gi");
			temp[0] = temp[0].replace(r, "$1network.peers[\"" + id + "\"]$2");
		}
		return reinsertQuotes(temp);
	}

	function initSampler() {
		if(updateToolOptions.vis_simulation_active) {
			console.info("Disabling the topology visualizer for more precise measurements. This can be re-enabled by clicking the dropdown above the table and selecting \"Toggle topology visualizer\".");
			toggleVisualizations();
		}
		if(updateToolOptions.minerStatsTable_active) {
			console.info("Disabling the miner stats table for improved performance. This can be re-enabled by clicking the dropdown above the table and selecting \"Toggle miner stats table\".");
			DOM_toggleMinerStatsTable();
		}

		network.stopAllMiners();
		network.removeBlocksInFlight();
		network.clearBlockchain();

		updateToolOptions.numSamples = 0;
		updateToolOptions.samplerData = [];
		updateToolOptions.samplerLog = [""];
		updateToolOptions.sampleTag = "";

		// Move the DOM textareas into the network logging code
		saveSamplerSettings();

		network.logging.codeBeforeSampling = getDynamicSampleCode(network.logging.codeBeforeSampling);
		let promise = null;
		try { // Run the user code before samples
			promise = eval(network.logging.codeBeforeSampling);
		} catch(e) {
			alert(e);
			console.warn(e);
		}

		if(!isPromise(promise)) promise = Promise.resolve(); // Temp promise resolves immediately

		promise.then(() => {
			// Keep these three columns outside the peer for loop since they are static columns
			if(network.logging.columns["Sample"]) updateToolOptions.samplerLog[0] += "Sample,";
			if(network.logging.columns["Sample time"]) updateToolOptions.samplerLog[0] += "Sample time,";
			if(network.logging.columns["Sample tag"]) updateToolOptions.samplerLog[0] += "Sample tag,";

			for(let id in network.peers) {
				for(let column in network.logging.columns) {
					if(column == "Sample") continue;
					if(column == "Sample time") continue;
					if(column == "Sample tag") continue;

					if(column == "Block num hops" || column == "Block travel time (s)") {
						if(!network.logging.logNetworkData) continue;
					}

					if(network.logging.columns[column]) {
						updateToolOptions.samplerLog[0] += column + ",";
					}
				}

				registerSamplerForId(id);
			}

			saveSamplerSettings();
			network.logging.codeBeforeSampling = getDynamicSampleCode(network.logging.codeBeforeSampling);
			network.logging.codeBetweenSamples = getDynamicSampleCode(network.logging.codeBetweenSamples);
			network.logging.codeAfterSampling = getDynamicSampleCode(network.logging.codeAfterSampling);
		});
	}

	function sample() {
		updateToolOptions.sampleEndTime = new Date().getTime();

		if(network.logging.resetBlockchainAfterEachSample) {
			network.stopAllMiners();
		}


		let sampleDuration = (updateToolOptions.sampleEndTime - updateToolOptions.sampleStartTime) / 1000;
		updateToolOptions.numSamples++;
		for(let id in network.ID_Registry) {
			let miner = network.peers[id];
			if(updateToolOptions.samplerData[id] === undefined) {
				// If new nodes were added since the beginning of logging, include them in the samples
				registerSamplerForId(id);
			}
			updateToolOptions.samplerData[id].sumBalance += miner.currentHeader.balances[id];
			updateToolOptions.samplerData[id].sumPower += miner.power;

			if(network.logging.logNetworkData) {
				try {
					let numHopsAvg = miner.blockchain_numHops.reduce((a, b) => a + b) / miner.blockchain_numHops.length;
					let blockDelayAvg = miner.blockchain_blockDelay.reduce((a, b) => a + b) / miner.blockchain_blockDelay.length;
					updateToolOptions.samplerData[id].sumNumHops += numHopsAvg;
					updateToolOptions.samplerData[id].sumBlockDelay += blockDelayAvg;
				} catch(e) {}
			}

			updateToolOptions.samplerData[id].sumLatency += miner.latency;
			updateToolOptions.samplerData[id].sumDownloadMBPS += miner.downloadMBPS;
			updateToolOptions.samplerData[id].sumUploadMBPS += miner.uploadMBPS;
			updateToolOptions.samplerData[id].sumBlockHeight += miner.currentHeader.height - 1;
			updateToolOptions.samplerData[id].sumTotalBlocks += miner.totalBlocksFound;
			updateToolOptions.samplerData[id].sumStaleBlocks += miner.staleBlocksFound;
			updateToolOptions.samplerData[id].sumMaxForkLength += miner.largestForkLength;
			updateToolOptions.samplerData[id].sumBlocksInFlight += miner.networkBuffer.buffer.length;
		}
		if(network.logging.logSamples) {
			let line = "", balanceTotal = 0, powerTotal = 0, latencyTotal = 0, downloadMBPSTotal = 0, uploadMBPSTotal = 0;
			if(network.logging.columns["Sample"]) line += "\"" + updateToolOptions.samplerLog.length + "\",";
			if(network.logging.columns["Sample time"]) line += "\"" + sampleDuration + "\",";
			if(network.logging.columns["Sample tag"]) line += "\"" + updateToolOptions.sampleTag + "\",";

			for(let id in network.ID_Registry) {
				let miner = network.peers[id];
				balanceTotal += miner.currentHeader.balances[id];
				powerTotal += miner.power;
				latencyTotal += miner.latency;
				downloadMBPSTotal += miner.downloadMBPS;
				uploadMBPSTotal += miner.uploadMBPS;
			}
			for(let id in network.ID_Registry) {
				let miner = network.peers[id];
				
				if(network.logging.columns["Miner name"]) line += "\"" + miner.name + "\",";
				if(network.logging.columns["Balance"]) line += "\"" + miner.currentHeader.balances[id] + "\",";
				if(network.logging.columns["Balance %"]) line += "\"" + (miner.currentHeader.balances[id] / balanceTotal * 100) + "\",";
				if(network.logging.columns["Power (hash/s)"]) line += "\"" + miner.power + "\",";
				if(network.logging.columns["Power %"]) line += "\"" + (miner.power / powerTotal * 100) + "\",";

				if(network.logging.logNetworkData) { // Keep track of networking data
					if(network.logging.columns["Block num hops"]) line += "\"" + miner.blockchain_numHops?.join(" ") + "\",";
					if(network.logging.columns["Block travel time (s)"]) line += "\"" + miner.blockchain_blockDelay?.join(" ") + "\",";
				}

				if(network.logging.columns["Network buffer size limit"]) line += "\"" + miner.networkBuffer.bufferSizeLimit + "\",";
				if(network.logging.columns["Blocks in flight"]) line += "\"" + miner.networkBuffer.buffer.length + "\",";
				if(network.logging.columns["Latency (ms)"]) line += "\"" + miner.latency + "\",";
				if(network.logging.columns["Download (MBPS)"]) line += "\"" + miner.downloadMBPS + "\",";
				if(network.logging.columns["Upload (MBPS)"]) line += "\"" + miner.uploadMBPS + "\",";
				if(network.logging.columns["Block height"]) line += "\"" + (miner.currentHeader.height - 1) + "\",";
				if(network.logging.columns["Total blocks found"]) line += "\"" + miner.totalBlocksFound + "\",";
				if(network.logging.columns["Stale blocks found"]) line += "\"" + miner.staleBlocksFound + "\",";
				if(network.logging.columns["Max fork length"]) line += "\"" + miner.largestForkLength + "\",";
			}
			updateToolOptions.samplerLog.push(line);
		}
		if(network.logging.resetBlockchainAfterEachSample) {
			network.removeBlocksInFlight();
			network.clearBlockchain();
		}

		if(network.logging.updateTableAfterEachSample) {
			updateSamplerTable();
		}
		let promise = null;
		try {
			promise = eval(network.logging.codeBetweenSamples);
		} catch(e) {
			console.warn(e, network.logging.codeBetweenSamples);
			//stopSampling();
			//return;
		}

		if(!isPromise(promise)) promise = Promise.resolve(); // Temp promise resolves immediately

		promise.then(() => { // Support promises being resolved in the code
			if(network.logging.resetBlockchainAfterEachSample) {
				network.startAllMiners();
			}
			if(updateToolOptions.sampler_running) {
				updateToolOptions.sampleStartTime = new Date().getTime();
				setTimeout(sample, network.logging.msPerSample);
			}
		});
	}

	function stopSampling() {
		try {
			eval(network.logging.codeAfterSampling);
		} catch(e) {
			alert(e);
			console.warn(e);
		}
		network.stopAllMiners();
		network.removeBlocksInFlight();
		network.clearBlockchain();
	}

	function updateSamplerTable() {
		let sampleDuration = (updateToolOptions.sampleEndTime - updateToolOptions.sampleStartTime) / 1000;
		let html = "<thead>"
		if(updateToolOptions.samplerLog.length > 1) {
			html += "<th colspan='3'><button onclick='downloadSampleLog()' class='btn btn-warning fillx'>Download log"
			// Display how many samples are logged, if it's different from the sample number (i.e. if samples were dynamically toggled during experiment)
			if(updateToolOptions.numSamples != updateToolOptions.samplerLog.length - 1) html += " (" + (updateToolOptions.samplerLog.length - 1) + ")"
			html += "</button></th>";
		}
		html += "<th colspan='8'><span class='text-warning lead'>" + updateToolOptions.numSamples + (updateToolOptions.numSamples == 1 ? " sample" : " samples") + " taken"
		if(updateToolOptions.sampler_running) html += " (" + sampleDuration + " seconds)";
		if(updateToolOptions.sampleTag.length > 0) html += " (" + updateToolOptions.sampleTag + ")";
		html += "</span>";
		html += "</thead><thead>";
		html += "<th scope='col'></th>";
		html += "<th scope='col'>Average<br>account balance</th>";
		html += "<th scope='col' class='text-warning'>%</th>";
		html += "<th scope='col'>Average<br>power (H/s)</th>";

		if(network.logging.logNetworkData) { // Keep track of networking data
			html += "<th scope='col'>Average<br>block num hops</th>";
			html += "<th scope='col'>Average<br>block travel time</th>";
		}
		html += "<th scope='col'>Average<br>blocks in flight</th>";

		html += "<th scope='col'>Average<br>latency (ms)</th>";
		html += "<th scope='col'>Average<br>download MBPS</th>";
		html += "<th scope='col'>Average<br>upload MBPS</th>";
		html += "<th scope='col'>Average<br>block height</th>";
		html += "<th scope='col'>Average<br>total blocks found</th>";
		html += "<th scope='col'>Average<br>stale blocks found</th>";
		html += "<th scope='col'>Average<br>max fork length</th>";
		html += "</thead>";
		html += "<tbody>";
		let miner, avgSumBalance, percentAvgSumBalance, miners = 0, sumAvgSumBalance = 0, avgPower, avgNumHops, avgBlockDelay, avgBlocksInFlight, avgLatency, avgDownloadMBPS, avgUploadMBPS, avgBlockHeight, avgTotalBlocks, avgStaleBlocks, avgMaxForkLength;
		

		for(let id in network.ID_Registry) {
			miners++;
			sumAvgSumBalance += updateToolOptions.samplerData[id].sumBalance / updateToolOptions.numSamples;
		}

		for(let id in network.ID_Registry) {
			miner = network.peers[id];
			avgSumBalance = Math.floor(updateToolOptions.samplerData[id].sumBalance / updateToolOptions.numSamples * 1000) / 1000;
			percentAvgSumBalance = Math.floor(avgSumBalance / sumAvgSumBalance * 100000) / 1000;
			avgPower = Math.floor(updateToolOptions.samplerData[id].sumPower / updateToolOptions.numSamples * 1000) / 1000;
			if(network.logging.logNetworkData) { // Keep track of networking data
				avgNumHops = Math.floor(updateToolOptions.samplerData[id].sumNumHops / updateToolOptions.numSamples * 1000) / 1000;
				avgBlockDelay = Math.floor(updateToolOptions.samplerData[id].sumBlockDelay / updateToolOptions.numSamples * 1000) / 1000;
			}
			avgBlocksInFlight = Math.floor(updateToolOptions.samplerData[id].sumBlocksInFlight / updateToolOptions.numSamples * 1000) / 1000;
			avgLatency = Math.floor(updateToolOptions.samplerData[id].sumLatency / updateToolOptions.numSamples * 1000) / 1000;
			avgDownloadMBPS = Math.floor(updateToolOptions.samplerData[id].sumDownloadMBPS / updateToolOptions.numSamples * 1000) / 1000;
			avgUploadMBPS = Math.floor(updateToolOptions.samplerData[id].sumUploadMBPS / updateToolOptions.numSamples * 1000) / 1000;
			avgBlockHeight = Math.floor(updateToolOptions.samplerData[id].sumBlockHeight / updateToolOptions.numSamples * 1000) / 1000;
			avgTotalBlocks = Math.floor(updateToolOptions.samplerData[id].sumTotalBlocks / updateToolOptions.numSamples * 1000) / 1000;
			avgStaleBlocks = Math.floor(updateToolOptions.samplerData[id].sumStaleBlocks / updateToolOptions.numSamples * 1000) / 1000;
			avgMaxForkLength = Math.floor(updateToolOptions.samplerData[id].sumMaxForkLength / updateToolOptions.numSamples * 1000) / 1000;
			html += "<tr onclick='selectMiner(\"" + miner.ID + "\")'>";
			html += "<th scope='col'>" + miner.name + "</th>";
			html += "<th scope='col'>" + avgSumBalance + " BTC</th>";
			html += "<th scope='col' class='text-warning'>" + percentAvgSumBalance + "</th>";
			html += "<th scope='col'>" + avgPower + "</th>";

			if(network.logging.logNetworkData) { // Keep track of networking data
				html += "<th scope='col'>" + avgNumHops + "</th>";
				html += "<th scope='col'>" + avgBlockDelay + "</th>";
			}
			html += "<th scope='col'>" + avgBlocksInFlight + "</th>";

			html += "<th scope='col'>" + avgLatency + "</th>";
			html += "<th scope='col'>" + avgDownloadMBPS + "</th>";
			html += "<th scope='col'>" + avgUploadMBPS + "</th>";
			html += "<th scope='col'>" + avgBlockHeight + "</th>";
			html += "<th scope='col'>" + avgTotalBlocks + "</th>";
			html += "<th scope='col'>" + avgStaleBlocks + "</th>";
			html += "<th scope='col'>" + avgMaxForkLength + "</th>";
			html += "</tr>";
		}
		html += "</tbody>";
		$("#sampleTable").html(html);
		if(updateToolOptions.minerStatsTable_active) updateMinerStatsTable();
	}

	function downloadSampleLog(name = "PoW_log_" + network.name.replace(/\s/g, '_') + ".csv") {
		// Confidence interval
		// =CONFIDENCE(0.05, STDEV(A2:A21), COUNT(A2:A21))
		let log = updateToolOptions.samplerLog.join("\r\n");
		let a=document.createElement("a");
		a.setAttribute("href","data:text/plain;charset=utf-8,"+encodeURIComponent(log));
		a.setAttribute("download", name);
		a.click();
	}

	// Canvas2SVG initialization
	// ["custom", "ellipse", "circle", "database", "box", "text", "image", "circularImage", "diamond", "dot", "star", "triangle", "triangleDown", "square", "icon", "hexagon"]

	C2S.prototype.dot = CanvasRenderingContext2D.prototype.dot;

	C2S.prototype.circle = CanvasRenderingContext2D.prototype.circle;
	C2S.prototype.dashedLine = CanvasRenderingContext2D.prototype.dashedLine;
	C2S.prototype.database = CanvasRenderingContext2D.prototype.database;
	C2S.prototype.diamond = CanvasRenderingContext2D.prototype.diamond;
	C2S.prototype.ellipse = CanvasRenderingContext2D.prototype.ellipse;
	C2S.prototype.ellipse_vis = CanvasRenderingContext2D.prototype.ellipse_vis;
	C2S.prototype.hexagon = CanvasRenderingContext2D.prototype.hexagon;
	C2S.prototype.roundRect = CanvasRenderingContext2D.prototype.roundRect;
	C2S.prototype.square = CanvasRenderingContext2D.prototype.square;
	C2S.prototype.star = CanvasRenderingContext2D.prototype.star;
	C2S.prototype.triangle = CanvasRenderingContext2D.prototype.triangle;
	C2S.prototype.triangleDown = CanvasRenderingContext2D.prototype.triangleDown;



	C2S.prototype.circle = CanvasRenderingContext2D.prototype.circle;
	C2S.prototype.square = CanvasRenderingContext2D.prototype.square;
	C2S.prototype.triangle = CanvasRenderingContext2D.prototype.triangle;
	C2S.prototype.triangleDown = CanvasRenderingContext2D.prototype.triangleDown;
	C2S.prototype.star = CanvasRenderingContext2D.prototype.star;
	C2S.prototype.diamond = CanvasRenderingContext2D.prototype.diamond;
	C2S.prototype.roundRect = CanvasRenderingContext2D.prototype.roundRect;
	C2S.prototype.ellipse_vis = CanvasRenderingContext2D.prototype.ellipse_vis;
	C2S.prototype.database = CanvasRenderingContext2D.prototype.database;
	C2S.prototype.arrowEndpoint = CanvasRenderingContext2D.prototype.arrowEndpoint;
	C2S.prototype.circleEndpoint = CanvasRenderingContext2D.prototype.circleEndpoint;
	C2S.prototype.dashedLine = CanvasRenderingContext2D.prototype.dashedLine;



	function exportSvg() {
		var networkContainer = updateToolOptions.vis_network.body.container;
		var ctx = new C2S({
			width: networkContainer.clientWidth,
			height: networkContainer.clientWidth,
			embedImages: true
		});

		var canvasProto = updateToolOptions.vis_network.canvas.__proto__;
		var currentGetContext = canvasProto.getContext;
		canvasProto.getContext = function() {
			return ctx;
		}
		var svgOptions = {
			nodes: {
				/*shape: "dot",
				size: 30,
				font: {
					size: 32,
					color: "#FFF"
				},
				borderWidth: 4,*/

				shapeProperties: {
					interpolation: false // So images are not scaled svg will get full image
				},
				scaling: {
					label: {
						drawThreshold: 0
					}
				},
				font: {
					color: "#000000"
				}
			},
			edges: {
				scaling: {
					label: {
						drawThreshold: 0
					}
				}
			}
		};

		//updateToolOptions.vis_network.setOptions(svgOptions);
		updateToolOptions.vis_network.redraw();
		//updateToolOptions.vis_network.setOptions(updateToolOptions.vis_network_options);
		canvasProto.getContext = currentGetContext;
		ctx.waitForComplete(function() {
			var svg = ctx.getSerializedSvg();
			showSvg(svg);
		});
	}

	function showSvg(svg) {
		var svgBlob = new Blob([svg], {
			type: "image/svg+xml"
		});
		openBlob(svgBlob, "blockchain_simulator_network.svg");
	}

	function openBlob(blob, fileName) {
		if (window.navigator && window.navigator.msSaveOrOpenBlob) {

			//blobToDataURL(blob, function(dataurl){window.open(dataurl);});
			window.navigator.msSaveOrOpenBlob(blob, fileName);
		} else {
			var a = document.getElementById("blobLink");
			if (!a) {
				a = document.createElement("a");
				document.body.appendChild(a);
				a.setAttribute("id", "blobLink");
				a.style = "display: none";
			}
			var data = window.URL.createObjectURL(blob);
			a.href = data;
			a.download = fileName;
			a.click();
			setTimeout(function() {
				// For Firefox it is necessary to delay revoking the ObjectURL
				window.URL.revokeObjectURL(data);
			}, 100);
		}
	}
</script>
</html>

